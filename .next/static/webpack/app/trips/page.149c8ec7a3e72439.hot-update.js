"use strict";
/*
 * ATTENTION: An "eval-source-map" devtool has been used.
 * This devtool is neither made for production nor for readable output files.
 * It uses "eval()" calls to create a separate source file with attached SourceMaps in the browser devtools.
 * If you are trying to read the output file, select a different devtool (https://webpack.js.org/configuration/devtool/)
 * or disable the default devtool with "devtool: false".
 * If you are looking for production-ready output files, see mode: "production" (https://webpack.js.org/configuration/mode/).
 */
self["webpackHotUpdate_N_E"]("app/trips/page",{

/***/ "(app-pages-browser)/./lib/queries.ts":
/*!************************!*\
  !*** ./lib/queries.ts ***!
  \************************/
/***/ (function(module, __webpack_exports__, __webpack_require__) {

eval(__webpack_require__.ts("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   assignDriverToBus: function() { return /* binding */ assignDriverToBus; },\n/* harmony export */   createRoute: function() { return /* binding */ createRoute; },\n/* harmony export */   deleteRoute: function() { return /* binding */ deleteRoute; },\n/* harmony export */   getActiveTrips: function() { return /* binding */ getActiveTrips; },\n/* harmony export */   getAllBuses: function() { return /* binding */ getAllBuses; },\n/* harmony export */   getAllRoutes: function() { return /* binding */ getAllRoutes; },\n/* harmony export */   getAllUsers: function() { return /* binding */ getAllUsers; },\n/* harmony export */   getConductors: function() { return /* binding */ getConductors; },\n/* harmony export */   getDashboardMetrics: function() { return /* binding */ getDashboardMetrics; },\n/* harmony export */   getDrivers: function() { return /* binding */ getDrivers; },\n/* harmony export */   getFleetStatus: function() { return /* binding */ getFleetStatus; },\n/* harmony export */   getRouteUtilization: function() { return /* binding */ getRouteUtilization; },\n/* harmony export */   getTravelHistory: function() { return /* binding */ getTravelHistory; },\n/* harmony export */   getTripAnalytics: function() { return /* binding */ getTripAnalytics; },\n/* harmony export */   getTripHistory: function() { return /* binding */ getTripHistory; },\n/* harmony export */   getUsersByRole: function() { return /* binding */ getUsersByRole; },\n/* harmony export */   updateBusAssignment: function() { return /* binding */ updateBusAssignment; },\n/* harmony export */   updateBusStatus: function() { return /* binding */ updateBusStatus; },\n/* harmony export */   updateRoute: function() { return /* binding */ updateRoute; },\n/* harmony export */   updateTripStatus: function() { return /* binding */ updateTripStatus; }\n/* harmony export */ });\n/* harmony import */ var _supabase__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./supabase */ \"(app-pages-browser)/./lib/supabase.ts\");\n\n// Dashboard Metrics Queries\nconst getDashboardMetrics = async ()=>{\n    const [{ count: activeBuses }, { count: ongoingTrips }, { count: totalRoutes }, { count: totalUsers }, { count: todayTrips }, { count: completedTrips }, { count: cancelledTrips }] = await Promise.all([\n        _supabase__WEBPACK_IMPORTED_MODULE_0__.supabase.from(\"buses\").select(\"*\", {\n            count: \"exact\",\n            head: true\n        }).eq(\"status\", \"active\"),\n        _supabase__WEBPACK_IMPORTED_MODULE_0__.supabase.from(\"trips\").select(\"*\", {\n            count: \"exact\",\n            head: true\n        }).eq(\"status\", \"ongoing\"),\n        _supabase__WEBPACK_IMPORTED_MODULE_0__.supabase.from(\"routes\").select(\"*\", {\n            count: \"exact\",\n            head: true\n        }),\n        _supabase__WEBPACK_IMPORTED_MODULE_0__.supabase.from(\"users\").select(\"*\", {\n            count: \"exact\",\n            head: true\n        }),\n        _supabase__WEBPACK_IMPORTED_MODULE_0__.supabase.from(\"trips\").select(\"*\", {\n            count: \"exact\",\n            head: true\n        }).gte(\"started_at\", new Date().toISOString().split(\"T\")[0]),\n        _supabase__WEBPACK_IMPORTED_MODULE_0__.supabase.from(\"trips\").select(\"*\", {\n            count: \"exact\",\n            head: true\n        }).eq(\"status\", \"completed\"),\n        _supabase__WEBPACK_IMPORTED_MODULE_0__.supabase.from(\"trips\").select(\"*\", {\n            count: \"exact\",\n            head: true\n        }).eq(\"status\", \"cancelled\")\n    ]);\n    // Get total passengers from trip_passengers\n    const { data: passengersData } = await _supabase__WEBPACK_IMPORTED_MODULE_0__.supabase.from(\"trip_passengers\").select(\"*\", {\n        count: \"exact\",\n        head: true\n    }).eq(\"status\", \"boarded\");\n    return {\n        activeBuses: activeBuses || 0,\n        ongoingTrips: ongoingTrips || 0,\n        totalRoutes: totalRoutes || 0,\n        totalPassengers: (passengersData === null || passengersData === void 0 ? void 0 : passengersData.length) || 0,\n        todayTrips: todayTrips || 0,\n        totalUsers: totalUsers || 0,\n        completedTrips: completedTrips || 0,\n        cancelledTrips: cancelledTrips || 0\n    };\n};\n// Fleet Management Queries\nconst getFleetStatus = async ()=>{\n    const { data, error } = await _supabase__WEBPACK_IMPORTED_MODULE_0__.supabase.from(\"buses\").select(\"\\n      id,\\n      plate_number,\\n      capacity,\\n      passengers,\\n      status,\\n      route_id,\\n      driver_id,\\n      routes (\\n        id,\\n        name,\\n        start_address,\\n        end_address\\n      ),\\n      driver:users!fk_driver (\\n        id,\\n        fullName,\\n        contact_number\\n      ),\\n      trips!inner (\\n        id,\\n        status,\\n        current_location\\n      )\\n    \").eq(\"trips.status\", \"ongoing\").order(\"plate_number\");\n    return {\n        data,\n        error\n    };\n};\nconst getAllBuses = async ()=>{\n    const { data, error } = await _supabase__WEBPACK_IMPORTED_MODULE_0__.supabase.from(\"buses\").select(\"\\n      id,\\n      plate_number,\\n      capacity,\\n      passengers,\\n      status,\\n      route_id,\\n      driver_id,\\n      conductor_id,\\n      routes (\\n        id,\\n        name,\\n        start_address,\\n        end_address\\n      ),\\n      driver:users!fk_driver (\\n        id,\\n        fullName,\\n        contact_number,\\n        license_number,\\n        license_expiry\\n      ),\\n      conductor:users!buses_conductor_id_fkey (\\n        id,\\n        fullName,\\n        contact_number\\n      )\\n    \").order(\"plate_number\");\n    return {\n        data,\n        error\n    };\n};\nconst getDrivers = async ()=>{\n    const { data, error } = await _supabase__WEBPACK_IMPORTED_MODULE_0__.supabase.from(\"users\").select(\"id, fullName, contact_number, license_number, license_expiry\").in(\"role\", [\n        \"driver\",\n        \"Driver\"\n    ]).order(\"fullName\");\n    return {\n        data,\n        error\n    };\n};\nconst getConductors = async ()=>{\n    const { data, error } = await _supabase__WEBPACK_IMPORTED_MODULE_0__.supabase.from(\"users\").select(\"id, fullName, contact_number\").in(\"role\", [\n        \"conductor\",\n        \"Conductor\"\n    ]).order(\"fullName\");\n    return {\n        data,\n        error\n    };\n};\n// Trip Management Queries\nconst getActiveTrips = async ()=>{\n    const { data, error } = await _supabase__WEBPACK_IMPORTED_MODULE_0__.supabase.from(\"trips\").select(\"\\n      id,\\n      status,\\n      current_location,\\n      started_at,\\n      buses (\\n        id,\\n        plate_number,\\n        capacity,\\n        routes (\\n          id,\\n          name,\\n          start_address,\\n          end_address\\n        )\\n      ),\\n      driver:users!trips_driver_id_fkey (\\n        id,\\n        fullName,\\n        contact_number\\n      ),\\n      trip_passengers (\\n        id,\\n        status,\\n        boarded_at,\\n        commuter:users (\\n          id,\\n          fullName\\n        )\\n      )\\n    \").in(\"status\", [\n        \"waiting\",\n        \"ongoing\"\n    ]).order(\"started_at\", {\n        ascending: false\n    });\n    return {\n        data,\n        error\n    };\n};\nconst getTripHistory = async function() {\n    let limit = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : 50;\n    const { data, error } = await _supabase__WEBPACK_IMPORTED_MODULE_0__.supabase.from(\"trips\").select(\"\\n      id,\\n      status,\\n      started_at,\\n      ended_at,\\n      cancelled_at,\\n      cancellation_reason,\\n      buses (\\n        id,\\n        plate_number,\\n        routes (\\n          id,\\n          name\\n        )\\n      ),\\n      driver:users!trips_driver_id_fkey (\\n        id,\\n        fullName\\n      ),\\n      trip_passengers (\\n        id,\\n        status\\n      )\\n    \").in(\"status\", [\n        \"completed\",\n        \"cancelled\"\n    ]).order(\"started_at\", {\n        ascending: false\n    }).limit(limit);\n    return {\n        data,\n        error\n    };\n};\n// User Management\nconst getAllUsers = async ()=>{\n    try {\n        // Try to get from users table\n        const { data, error } = await _supabase__WEBPACK_IMPORTED_MODULE_0__.supabase.from(\"users\").select(\"*\").order(\"updated_at\", {\n            ascending: false\n        });\n        if (error) {\n            console.log(\"Users table query failed:\", error.message);\n            // Return empty array instead of error to prevent UI crashes\n            return {\n                data: [],\n                error: null\n            };\n        }\n        return {\n            data,\n            error\n        };\n    } catch (error) {\n        console.error(\"Error in getAllUsers:\", error);\n        return {\n            data: [],\n            error: null\n        };\n    }\n};\nconst getUsersByRole = async (role)=>{\n    try {\n        // Try to get from users table\n        const { data, error } = await _supabase__WEBPACK_IMPORTED_MODULE_0__.supabase.from(\"users\").select(\"*\").eq(\"role\", role).order(\"fullName\");\n        if (error) {\n            console.log(\"Users table query failed for role:\", role, error.message);\n            // Return empty array instead of error to prevent UI crashes\n            return {\n                data: [],\n                error: null\n            };\n        }\n        return {\n            data,\n            error\n        };\n    } catch (error) {\n        console.error(\"Error in getUsersByRole:\", error);\n        return {\n            data: [],\n            error: null\n        };\n    }\n};\n// Route Management Queries\nconst getAllRoutes = async ()=>{\n    const { data, error } = await _supabase__WEBPACK_IMPORTED_MODULE_0__.supabase.from(\"routes\").select(\"*\").order(\"created_at\", {\n        ascending: false\n    });\n    return {\n        data,\n        error\n    };\n};\nconst createRoute = async (routeData)=>{\n    try {\n        // For PostGIS geography columns, we need to use ST_GeogFromGeoJSON\n        // But supabase-js doesn't support this directly, so we'll use RPC\n        const { data, error } = await _supabase__WEBPACK_IMPORTED_MODULE_0__.supabase.rpc(\"insert_route\", {\n            p_name: routeData.name,\n            p_start_address: routeData.start_address,\n            p_end_address: routeData.end_address,\n            p_path_geojson: routeData.path\n        });\n        if (error) {\n            console.error(\"createRoute error:\", error);\n            return {\n                data: null,\n                error\n            };\n        }\n        return {\n            data,\n            error: null\n        };\n    } catch (err) {\n        console.error(\"createRoute exception:\", err);\n        return {\n            data: null,\n            error: {\n                message: String(err)\n            }\n        };\n    }\n};\nconst updateRoute = async (routeId, routeData)=>{\n    try {\n        // Use RPC function for PostGIS geography handling\n        const { data, error } = await _supabase__WEBPACK_IMPORTED_MODULE_0__.supabase.rpc(\"update_route\", {\n            p_route_id: routeId,\n            p_name: routeData.name || null,\n            p_start_address: routeData.start_address || null,\n            p_end_address: routeData.end_address || null,\n            p_path_geojson: routeData.path || null\n        });\n        if (error) {\n            console.error(\"updateRoute error:\", error);\n            return {\n                data: null,\n                error\n            };\n        }\n        return {\n            data,\n            error: null\n        };\n    } catch (err) {\n        console.error(\"updateRoute exception:\", err);\n        return {\n            data: null,\n            error: {\n                message: String(err)\n            }\n        };\n    }\n};\nconst deleteRoute = async (routeId)=>{\n    try {\n        const { data, error } = await _supabase__WEBPACK_IMPORTED_MODULE_0__.supabase.from(\"routes\").delete().eq(\"id\", routeId);\n        if (error) {\n            console.error(\"deleteRoute error:\", error);\n            return {\n                data: null,\n                error\n            };\n        }\n        return {\n            data,\n            error: null\n        };\n    } catch (err) {\n        console.error(\"deleteRoute exception:\", err);\n        return {\n            data: null,\n            error: {\n                message: String(err)\n            }\n        };\n    }\n};\n// Analytics Queries\nconst getTripAnalytics = async function() {\n    let days = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : 30;\n    const { data, error } = await _supabase__WEBPACK_IMPORTED_MODULE_0__.supabase.from(\"trips\").select(\"\\n      id,\\n      status,\\n      started_at,\\n      ended_at,\\n      buses (\\n        routes (\\n          name\\n        )\\n      )\\n    \").gte(\"started_at\", new Date(Date.now() - days * 24 * 60 * 60 * 1000).toISOString()).order(\"started_at\", {\n        ascending: false\n    });\n    return {\n        data,\n        error\n    };\n};\nconst getRouteUtilization = async ()=>{\n    const { data, error } = await _supabase__WEBPACK_IMPORTED_MODULE_0__.supabase.from(\"routes\").select(\"\\n      id,\\n      name,\\n      start_address,\\n      end_address,\\n      buses (\\n        id,\\n        plate_number,\\n        status,\\n        trips (\\n          id,\\n          status,\\n          started_at\\n        )\\n      )\\n    \");\n    return {\n        data,\n        error\n    };\n};\nconst getTravelHistory = async function() {\n    let limit = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : 100;\n    // Try to get from travel_history_commuter table with proper join\n    const { data: commuterData, error: commuterError } = await _supabase__WEBPACK_IMPORTED_MODULE_0__.supabase.from(\"travel_history_commuter\").select(\"\\n      id,\\n      start_location_name,\\n      end_location_name,\\n      travel_date,\\n      route_name,\\n      status,\\n      user:users (\\n        id,\\n        fullName\\n      )\\n    \").order(\"travel_date\", {\n        ascending: false\n    }).limit(limit);\n    // If successful, return the data\n    if (commuterData && !commuterError) {\n        return {\n            data: commuterData,\n            error: null\n        };\n    }\n    // If travel_history_commuter table doesn't exist, fall back to trips table\n    if (commuterError && commuterError.code === \"PGRST200\") {\n        const { data: tripsData, error: tripsError } = await _supabase__WEBPACK_IMPORTED_MODULE_0__.supabase.from(\"trips\").select(\"\\n        id,\\n        status,\\n        started_at,\\n        ended_at,\\n        buses (\\n          routes (\\n            name,\\n            start_address,\\n            end_address\\n          )\\n        ),\\n        driver:users!trips_driver_id_fkey (\\n          id,\\n          fullName\\n        )\\n      \").in(\"status\", [\n            \"completed\",\n            \"cancelled\"\n        ]).order(\"started_at\", {\n            ascending: false\n        }).limit(limit);\n        if (tripsError) {\n            return {\n                data: null,\n                error: tripsError\n            };\n        }\n        // Transform trips data to match expected format\n        const transformedData = (tripsData === null || tripsData === void 0 ? void 0 : tripsData.map((trip)=>{\n            var _trip_buses_routes, _trip_buses, _trip_buses_routes1, _trip_buses1, _trip_started_at, _trip_buses_routes2, _trip_buses2;\n            return {\n                id: trip.id,\n                start_location_name: ((_trip_buses = trip.buses) === null || _trip_buses === void 0 ? void 0 : (_trip_buses_routes = _trip_buses.routes) === null || _trip_buses_routes === void 0 ? void 0 : _trip_buses_routes.start_address) || \"Unknown\",\n                end_location_name: ((_trip_buses1 = trip.buses) === null || _trip_buses1 === void 0 ? void 0 : (_trip_buses_routes1 = _trip_buses1.routes) === null || _trip_buses_routes1 === void 0 ? void 0 : _trip_buses_routes1.end_address) || \"Unknown\",\n                travel_date: ((_trip_started_at = trip.started_at) === null || _trip_started_at === void 0 ? void 0 : _trip_started_at.split(\"T\")[0]) || new Date().toISOString().split(\"T\")[0],\n                route_name: ((_trip_buses2 = trip.buses) === null || _trip_buses2 === void 0 ? void 0 : (_trip_buses_routes2 = _trip_buses2.routes) === null || _trip_buses_routes2 === void 0 ? void 0 : _trip_buses_routes2.name) || \"Unknown Route\",\n                status: trip.status,\n                created_at: trip.started_at,\n                user: trip.driver\n            };\n        })) || [];\n        return {\n            data: transformedData,\n            error: null\n        };\n    }\n    return {\n        data: commuterData,\n        error: commuterError\n    };\n};\n// Update Operations\nconst updateBusStatus = async (busId, status)=>{\n    const { data, error } = await _supabase__WEBPACK_IMPORTED_MODULE_0__.supabase.from(\"buses\").update({\n        status,\n        updated_at: new Date().toISOString()\n    }).eq(\"id\", busId).select();\n    return {\n        data,\n        error\n    };\n};\nconst assignDriverToBus = async (busId, driverId)=>{\n    const { data, error } = await _supabase__WEBPACK_IMPORTED_MODULE_0__.supabase.from(\"buses\").update({\n        driver_id: driverId,\n        updated_at: new Date().toISOString()\n    }).eq(\"id\", busId).select();\n    return {\n        data,\n        error\n    };\n};\nconst updateBusAssignment = async (busId, updates)=>{\n    const { driverId, conductorId } = updates;\n    const updatePayload = {\n        updated_at: new Date().toISOString()\n    };\n    if (driverId !== undefined) updatePayload.driver_id = driverId;\n    if (conductorId !== undefined) updatePayload.conductor_id = conductorId;\n    const { data, error } = await _supabase__WEBPACK_IMPORTED_MODULE_0__.supabase.from(\"buses\").update(updatePayload).eq(\"id\", busId).select();\n    return {\n        data,\n        error\n    };\n};\nconst updateTripStatus = async (tripId, status, currentLocation)=>{\n    const updateData = {\n        status,\n        updated_at: new Date().toISOString()\n    };\n    if (currentLocation) {\n        updateData.current_location = currentLocation;\n    }\n    if (status === \"completed\") {\n        updateData.ended_at = new Date().toISOString();\n    } else if (status === \"cancelled\") {\n        updateData.cancelled_at = new Date().toISOString();\n    }\n    const { data, error } = await _supabase__WEBPACK_IMPORTED_MODULE_0__.supabase.from(\"trips\").update(updateData).eq(\"id\", tripId).select();\n    return {\n        data,\n        error\n    };\n};\n\n\n;\n    // Wrapped in an IIFE to avoid polluting the global scope\n    ;\n    (function () {\n        var _a, _b;\n        // Legacy CSS implementations will `eval` browser code in a Node.js context\n        // to extract CSS. For backwards compatibility, we need to check we're in a\n        // browser context before continuing.\n        if (typeof self !== 'undefined' &&\n            // AMP / No-JS mode does not inject these helpers:\n            '$RefreshHelpers$' in self) {\n            // @ts-ignore __webpack_module__ is global\n            var currentExports = module.exports;\n            // @ts-ignore __webpack_module__ is global\n            var prevSignature = (_b = (_a = module.hot.data) === null || _a === void 0 ? void 0 : _a.prevSignature) !== null && _b !== void 0 ? _b : null;\n            // This cannot happen in MainTemplate because the exports mismatch between\n            // templating and execution.\n            self.$RefreshHelpers$.registerExportsForReactRefresh(currentExports, module.id);\n            // A module can be accepted automatically based on its exports, e.g. when\n            // it is a Refresh Boundary.\n            if (self.$RefreshHelpers$.isReactRefreshBoundary(currentExports)) {\n                // Save the previous exports signature on update so we can compare the boundary\n                // signatures. We avoid saving exports themselves since it causes memory leaks (https://github.com/vercel/next.js/pull/53797)\n                module.hot.dispose(function (data) {\n                    data.prevSignature =\n                        self.$RefreshHelpers$.getRefreshBoundarySignature(currentExports);\n                });\n                // Unconditionally accept an update to this module, we'll check if it's\n                // still a Refresh Boundary later.\n                // @ts-ignore importMeta is replaced in the loader\n                module.hot.accept();\n                // This field is set when the previous version of this module was a\n                // Refresh Boundary, letting us know we need to check for invalidation or\n                // enqueue an update.\n                if (prevSignature !== null) {\n                    // A boundary can become ineligible if its exports are incompatible\n                    // with the previous exports.\n                    //\n                    // For example, if you add/remove/change exports, we'll want to\n                    // re-execute the importing modules, and force those components to\n                    // re-render. Similarly, if you convert a class component to a\n                    // function, we want to invalidate the boundary.\n                    if (self.$RefreshHelpers$.shouldInvalidateReactRefreshBoundary(prevSignature, self.$RefreshHelpers$.getRefreshBoundarySignature(currentExports))) {\n                        module.hot.invalidate();\n                    }\n                    else {\n                        self.$RefreshHelpers$.scheduleUpdate();\n                    }\n                }\n            }\n            else {\n                // Since we just executed the code for the module, it's possible that the\n                // new exports made it ineligible for being a boundary.\n                // We only care about the case when we were _previously_ a boundary,\n                // because we already accepted this update (accidental side effect).\n                var isNoLongerABoundary = prevSignature !== null;\n                if (isNoLongerABoundary) {\n                    module.hot.invalidate();\n                }\n            }\n        }\n    })();\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,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SUFDOUMsT0FBTyxJQUFJK0QsV0FBVyxhQUFhO1FBQ2pDb0IsV0FBV0csWUFBWSxHQUFHLElBQUl2RixPQUFPQyxXQUFXO0lBQ2xEO0lBRUEsTUFBTSxFQUFFRSxJQUFJLEVBQUVLLEtBQUssRUFBRSxHQUFHLE1BQU16QiwrQ0FBUUEsQ0FDbkNZLElBQUksQ0FBQyxTQUNMMkUsTUFBTSxDQUFDYyxZQUNQdEYsRUFBRSxDQUFDLE1BQU1vRixRQUNUdEYsTUFBTTtJQUVULE9BQU87UUFBRU87UUFBTUs7SUFBTTtBQUN2QixFQUFFIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vX05fRS8uL2xpYi9xdWVyaWVzLnRzPzhhODEiXSwic291cmNlc0NvbnRlbnQiOlsiaW1wb3J0IHsgRGFzaGJvYXJkTWV0cmljcywgc3VwYWJhc2UgfSBmcm9tIFwiLi9zdXBhYmFzZVwiO1xyXG5cclxuLy8gUmUtZXhwb3J0IHR5cGVzIGZvciB1c2UgaW4gY29tcG9uZW50c1xyXG5leHBvcnQgdHlwZSB7IERhc2hib2FyZE1ldHJpY3MgfTtcclxuXHJcbi8vIERhc2hib2FyZCBNZXRyaWNzIFF1ZXJpZXNcclxuZXhwb3J0IGNvbnN0IGdldERhc2hib2FyZE1ldHJpY3MgPSBhc3luYyAoKTogUHJvbWlzZTxEYXNoYm9hcmRNZXRyaWNzPiA9PiB7XHJcbiAgY29uc3QgW1xyXG4gICAgeyBjb3VudDogYWN0aXZlQnVzZXMgfSxcclxuICAgIHsgY291bnQ6IG9uZ29pbmdUcmlwcyB9LFxyXG4gICAgeyBjb3VudDogdG90YWxSb3V0ZXMgfSxcclxuICAgIHsgY291bnQ6IHRvdGFsVXNlcnMgfSxcclxuICAgIHsgY291bnQ6IHRvZGF5VHJpcHMgfSxcclxuICAgIHsgY291bnQ6IGNvbXBsZXRlZFRyaXBzIH0sXHJcbiAgICB7IGNvdW50OiBjYW5jZWxsZWRUcmlwcyB9LFxyXG4gIF0gPSBhd2FpdCBQcm9taXNlLmFsbChbXHJcbiAgICBzdXBhYmFzZVxyXG4gICAgICAuZnJvbShcImJ1c2VzXCIpXHJcbiAgICAgIC5zZWxlY3QoXCIqXCIsIHsgY291bnQ6IFwiZXhhY3RcIiwgaGVhZDogdHJ1ZSB9KVxyXG4gICAgICAuZXEoXCJzdGF0dXNcIiwgXCJhY3RpdmVcIiksXHJcbiAgICBzdXBhYmFzZVxyXG4gICAgICAuZnJvbShcInRyaXBzXCIpXHJcbiAgICAgIC5zZWxlY3QoXCIqXCIsIHsgY291bnQ6IFwiZXhhY3RcIiwgaGVhZDogdHJ1ZSB9KVxyXG4gICAgICAuZXEoXCJzdGF0dXNcIiwgXCJvbmdvaW5nXCIpLFxyXG4gICAgc3VwYWJhc2UuZnJvbShcInJvdXRlc1wiKS5zZWxlY3QoXCIqXCIsIHsgY291bnQ6IFwiZXhhY3RcIiwgaGVhZDogdHJ1ZSB9KSxcclxuICAgIHN1cGFiYXNlLmZyb20oXCJ1c2Vyc1wiKS5zZWxlY3QoXCIqXCIsIHsgY291bnQ6IFwiZXhhY3RcIiwgaGVhZDogdHJ1ZSB9KSxcclxuICAgIHN1cGFiYXNlXHJcbiAgICAgIC5mcm9tKFwidHJpcHNcIilcclxuICAgICAgLnNlbGVjdChcIipcIiwgeyBjb3VudDogXCJleGFjdFwiLCBoZWFkOiB0cnVlIH0pXHJcbiAgICAgIC5ndGUoXCJzdGFydGVkX2F0XCIsIG5ldyBEYXRlKCkudG9JU09TdHJpbmcoKS5zcGxpdChcIlRcIilbMF0pLFxyXG4gICAgc3VwYWJhc2VcclxuICAgICAgLmZyb20oXCJ0cmlwc1wiKVxyXG4gICAgICAuc2VsZWN0KFwiKlwiLCB7IGNvdW50OiBcImV4YWN0XCIsIGhlYWQ6IHRydWUgfSlcclxuICAgICAgLmVxKFwic3RhdHVzXCIsIFwiY29tcGxldGVkXCIpLFxyXG4gICAgc3VwYWJhc2VcclxuICAgICAgLmZyb20oXCJ0cmlwc1wiKVxyXG4gICAgICAuc2VsZWN0KFwiKlwiLCB7IGNvdW50OiBcImV4YWN0XCIsIGhlYWQ6IHRydWUgfSlcclxuICAgICAgLmVxKFwic3RhdHVzXCIsIFwiY2FuY2VsbGVkXCIpLFxyXG4gIF0pO1xyXG5cclxuICAvLyBHZXQgdG90YWwgcGFzc2VuZ2VycyBmcm9tIHRyaXBfcGFzc2VuZ2Vyc1xyXG4gIGNvbnN0IHsgZGF0YTogcGFzc2VuZ2Vyc0RhdGEgfSA9IGF3YWl0IHN1cGFiYXNlXHJcbiAgICAuZnJvbShcInRyaXBfcGFzc2VuZ2Vyc1wiKVxyXG4gICAgLnNlbGVjdChcIipcIiwgeyBjb3VudDogXCJleGFjdFwiLCBoZWFkOiB0cnVlIH0pXHJcbiAgICAuZXEoXCJzdGF0dXNcIiwgXCJib2FyZGVkXCIpO1xyXG5cclxuICByZXR1cm4ge1xyXG4gICAgYWN0aXZlQnVzZXM6IGFjdGl2ZUJ1c2VzIHx8IDAsXHJcbiAgICBvbmdvaW5nVHJpcHM6IG9uZ29pbmdUcmlwcyB8fCAwLFxyXG4gICAgdG90YWxSb3V0ZXM6IHRvdGFsUm91dGVzIHx8IDAsXHJcbiAgICB0b3RhbFBhc3NlbmdlcnM6IHBhc3NlbmdlcnNEYXRhPy5sZW5ndGggfHwgMCxcclxuICAgIHRvZGF5VHJpcHM6IHRvZGF5VHJpcHMgfHwgMCxcclxuICAgIHRvdGFsVXNlcnM6IHRvdGFsVXNlcnMgfHwgMCxcclxuICAgIGNvbXBsZXRlZFRyaXBzOiBjb21wbGV0ZWRUcmlwcyB8fCAwLFxyXG4gICAgY2FuY2VsbGVkVHJpcHM6IGNhbmNlbGxlZFRyaXBzIHx8IDAsXHJcbiAgfTtcclxufTtcclxuXHJcbi8vIEZsZWV0IE1hbmFnZW1lbnQgUXVlcmllc1xyXG5leHBvcnQgY29uc3QgZ2V0RmxlZXRTdGF0dXMgPSBhc3luYyAoKSA9PiB7XHJcbiAgY29uc3QgeyBkYXRhLCBlcnJvciB9ID0gYXdhaXQgc3VwYWJhc2VcclxuICAgIC5mcm9tKFwiYnVzZXNcIilcclxuICAgIC5zZWxlY3QoXHJcbiAgICAgIGBcclxuICAgICAgaWQsXHJcbiAgICAgIHBsYXRlX251bWJlcixcclxuICAgICAgY2FwYWNpdHksXHJcbiAgICAgIHBhc3NlbmdlcnMsXHJcbiAgICAgIHN0YXR1cyxcclxuICAgICAgcm91dGVfaWQsXHJcbiAgICAgIGRyaXZlcl9pZCxcclxuICAgICAgcm91dGVzIChcclxuICAgICAgICBpZCxcclxuICAgICAgICBuYW1lLFxyXG4gICAgICAgIHN0YXJ0X2FkZHJlc3MsXHJcbiAgICAgICAgZW5kX2FkZHJlc3NcclxuICAgICAgKSxcclxuICAgICAgZHJpdmVyOnVzZXJzIWZrX2RyaXZlciAoXHJcbiAgICAgICAgaWQsXHJcbiAgICAgICAgZnVsbE5hbWUsXHJcbiAgICAgICAgY29udGFjdF9udW1iZXJcclxuICAgICAgKSxcclxuICAgICAgdHJpcHMhaW5uZXIgKFxyXG4gICAgICAgIGlkLFxyXG4gICAgICAgIHN0YXR1cyxcclxuICAgICAgICBjdXJyZW50X2xvY2F0aW9uXHJcbiAgICAgIClcclxuICAgIGBcclxuICAgIClcclxuICAgIC5lcShcInRyaXBzLnN0YXR1c1wiLCBcIm9uZ29pbmdcIilcclxuICAgIC5vcmRlcihcInBsYXRlX251bWJlclwiKTtcclxuXHJcbiAgcmV0dXJuIHsgZGF0YSwgZXJyb3IgfTtcclxufTtcclxuXHJcbmV4cG9ydCBjb25zdCBnZXRBbGxCdXNlcyA9IGFzeW5jICgpID0+IHtcclxuICBjb25zdCB7IGRhdGEsIGVycm9yIH0gPSBhd2FpdCBzdXBhYmFzZVxyXG4gICAgLmZyb20oXCJidXNlc1wiKVxyXG4gICAgLnNlbGVjdChcclxuICAgICAgYFxyXG4gICAgICBpZCxcclxuICAgICAgcGxhdGVfbnVtYmVyLFxyXG4gICAgICBjYXBhY2l0eSxcclxuICAgICAgcGFzc2VuZ2VycyxcclxuICAgICAgc3RhdHVzLFxyXG4gICAgICByb3V0ZV9pZCxcclxuICAgICAgZHJpdmVyX2lkLFxyXG4gICAgICBjb25kdWN0b3JfaWQsXHJcbiAgICAgIHJvdXRlcyAoXHJcbiAgICAgICAgaWQsXHJcbiAgICAgICAgbmFtZSxcclxuICAgICAgICBzdGFydF9hZGRyZXNzLFxyXG4gICAgICAgIGVuZF9hZGRyZXNzXHJcbiAgICAgICksXHJcbiAgICAgIGRyaXZlcjp1c2VycyFma19kcml2ZXIgKFxyXG4gICAgICAgIGlkLFxyXG4gICAgICAgIGZ1bGxOYW1lLFxyXG4gICAgICAgIGNvbnRhY3RfbnVtYmVyLFxyXG4gICAgICAgIGxpY2Vuc2VfbnVtYmVyLFxyXG4gICAgICAgIGxpY2Vuc2VfZXhwaXJ5XHJcbiAgICAgICksXHJcbiAgICAgIGNvbmR1Y3Rvcjp1c2VycyFidXNlc19jb25kdWN0b3JfaWRfZmtleSAoXHJcbiAgICAgICAgaWQsXHJcbiAgICAgICAgZnVsbE5hbWUsXHJcbiAgICAgICAgY29udGFjdF9udW1iZXJcclxuICAgICAgKVxyXG4gICAgYFxyXG4gICAgKVxyXG4gICAgLm9yZGVyKFwicGxhdGVfbnVtYmVyXCIpO1xyXG5cclxuICByZXR1cm4geyBkYXRhLCBlcnJvciB9O1xyXG59O1xyXG5cclxuZXhwb3J0IGNvbnN0IGdldERyaXZlcnMgPSBhc3luYyAoKSA9PiB7XHJcbiAgY29uc3QgeyBkYXRhLCBlcnJvciB9ID0gYXdhaXQgc3VwYWJhc2VcclxuICAgIC5mcm9tKFwidXNlcnNcIilcclxuICAgIC5zZWxlY3QoXCJpZCwgZnVsbE5hbWUsIGNvbnRhY3RfbnVtYmVyLCBsaWNlbnNlX251bWJlciwgbGljZW5zZV9leHBpcnlcIilcclxuICAgIC5pbihcInJvbGVcIiwgW1wiZHJpdmVyXCIsIFwiRHJpdmVyXCJdKVxyXG4gICAgLm9yZGVyKFwiZnVsbE5hbWVcIik7XHJcblxyXG4gIHJldHVybiB7IGRhdGEsIGVycm9yIH07XHJcbn07XHJcblxyXG5leHBvcnQgY29uc3QgZ2V0Q29uZHVjdG9ycyA9IGFzeW5jICgpID0+IHtcclxuICBjb25zdCB7IGRhdGEsIGVycm9yIH0gPSBhd2FpdCBzdXBhYmFzZVxyXG4gICAgLmZyb20oXCJ1c2Vyc1wiKVxyXG4gICAgLnNlbGVjdChcImlkLCBmdWxsTmFtZSwgY29udGFjdF9udW1iZXJcIilcclxuICAgIC5pbihcInJvbGVcIiwgW1wiY29uZHVjdG9yXCIsIFwiQ29uZHVjdG9yXCJdKVxyXG4gICAgLm9yZGVyKFwiZnVsbE5hbWVcIik7XHJcblxyXG4gIHJldHVybiB7IGRhdGEsIGVycm9yIH07XHJcbn07XHJcblxyXG4vLyBUcmlwIE1hbmFnZW1lbnQgUXVlcmllc1xyXG5leHBvcnQgY29uc3QgZ2V0QWN0aXZlVHJpcHMgPSBhc3luYyAoKSA9PiB7XHJcbiAgY29uc3QgeyBkYXRhLCBlcnJvciB9ID0gYXdhaXQgc3VwYWJhc2VcclxuICAgIC5mcm9tKFwidHJpcHNcIilcclxuICAgIC5zZWxlY3QoXHJcbiAgICAgIGBcclxuICAgICAgaWQsXHJcbiAgICAgIHN0YXR1cyxcclxuICAgICAgY3VycmVudF9sb2NhdGlvbixcclxuICAgICAgc3RhcnRlZF9hdCxcclxuICAgICAgYnVzZXMgKFxyXG4gICAgICAgIGlkLFxyXG4gICAgICAgIHBsYXRlX251bWJlcixcclxuICAgICAgICBjYXBhY2l0eSxcclxuICAgICAgICByb3V0ZXMgKFxyXG4gICAgICAgICAgaWQsXHJcbiAgICAgICAgICBuYW1lLFxyXG4gICAgICAgICAgc3RhcnRfYWRkcmVzcyxcclxuICAgICAgICAgIGVuZF9hZGRyZXNzXHJcbiAgICAgICAgKVxyXG4gICAgICApLFxyXG4gICAgICBkcml2ZXI6dXNlcnMhdHJpcHNfZHJpdmVyX2lkX2ZrZXkgKFxyXG4gICAgICAgIGlkLFxyXG4gICAgICAgIGZ1bGxOYW1lLFxyXG4gICAgICAgIGNvbnRhY3RfbnVtYmVyXHJcbiAgICAgICksXHJcbiAgICAgIHRyaXBfcGFzc2VuZ2VycyAoXHJcbiAgICAgICAgaWQsXHJcbiAgICAgICAgc3RhdHVzLFxyXG4gICAgICAgIGJvYXJkZWRfYXQsXHJcbiAgICAgICAgY29tbXV0ZXI6dXNlcnMgKFxyXG4gICAgICAgICAgaWQsXHJcbiAgICAgICAgICBmdWxsTmFtZVxyXG4gICAgICAgIClcclxuICAgICAgKVxyXG4gICAgYFxyXG4gICAgKVxyXG4gICAgLmluKFwic3RhdHVzXCIsIFtcIndhaXRpbmdcIiwgXCJvbmdvaW5nXCJdKVxyXG4gICAgLm9yZGVyKFwic3RhcnRlZF9hdFwiLCB7IGFzY2VuZGluZzogZmFsc2UgfSk7XHJcblxyXG4gIHJldHVybiB7IGRhdGEsIGVycm9yIH07XHJcbn07XHJcblxyXG5leHBvcnQgY29uc3QgZ2V0VHJpcEhpc3RvcnkgPSBhc3luYyAobGltaXQgPSA1MCkgPT4ge1xyXG4gIGNvbnN0IHsgZGF0YSwgZXJyb3IgfSA9IGF3YWl0IHN1cGFiYXNlXHJcbiAgICAuZnJvbShcInRyaXBzXCIpXHJcbiAgICAuc2VsZWN0KFxyXG4gICAgICBgXHJcbiAgICAgIGlkLFxyXG4gICAgICBzdGF0dXMsXHJcbiAgICAgIHN0YXJ0ZWRfYXQsXHJcbiAgICAgIGVuZGVkX2F0LFxyXG4gICAgICBjYW5jZWxsZWRfYXQsXHJcbiAgICAgIGNhbmNlbGxhdGlvbl9yZWFzb24sXHJcbiAgICAgIGJ1c2VzIChcclxuICAgICAgICBpZCxcclxuICAgICAgICBwbGF0ZV9udW1iZXIsXHJcbiAgICAgICAgcm91dGVzIChcclxuICAgICAgICAgIGlkLFxyXG4gICAgICAgICAgbmFtZVxyXG4gICAgICAgIClcclxuICAgICAgKSxcclxuICAgICAgZHJpdmVyOnVzZXJzIXRyaXBzX2RyaXZlcl9pZF9ma2V5IChcclxuICAgICAgICBpZCxcclxuICAgICAgICBmdWxsTmFtZVxyXG4gICAgICApLFxyXG4gICAgICB0cmlwX3Bhc3NlbmdlcnMgKFxyXG4gICAgICAgIGlkLFxyXG4gICAgICAgIHN0YXR1c1xyXG4gICAgICApXHJcbiAgICBgXHJcbiAgICApXHJcbiAgICAuaW4oXCJzdGF0dXNcIiwgW1wiY29tcGxldGVkXCIsIFwiY2FuY2VsbGVkXCJdKVxyXG4gICAgLm9yZGVyKFwic3RhcnRlZF9hdFwiLCB7IGFzY2VuZGluZzogZmFsc2UgfSlcclxuICAgIC5saW1pdChsaW1pdCk7XHJcblxyXG4gIHJldHVybiB7IGRhdGEsIGVycm9yIH07XHJcbn07XHJcblxyXG4vLyBVc2VyIE1hbmFnZW1lbnRcclxuZXhwb3J0IGNvbnN0IGdldEFsbFVzZXJzID0gYXN5bmMgKCkgPT4ge1xyXG4gIHRyeSB7XHJcbiAgICAvLyBUcnkgdG8gZ2V0IGZyb20gdXNlcnMgdGFibGVcclxuICAgIGNvbnN0IHsgZGF0YSwgZXJyb3IgfSA9IGF3YWl0IHN1cGFiYXNlXHJcbiAgICAgIC5mcm9tKFwidXNlcnNcIilcclxuICAgICAgLnNlbGVjdChcIipcIilcclxuICAgICAgLm9yZGVyKFwidXBkYXRlZF9hdFwiLCB7IGFzY2VuZGluZzogZmFsc2UgfSk7XHJcblxyXG4gICAgaWYgKGVycm9yKSB7XHJcbiAgICAgIGNvbnNvbGUubG9nKFwiVXNlcnMgdGFibGUgcXVlcnkgZmFpbGVkOlwiLCBlcnJvci5tZXNzYWdlKTtcclxuICAgICAgLy8gUmV0dXJuIGVtcHR5IGFycmF5IGluc3RlYWQgb2YgZXJyb3IgdG8gcHJldmVudCBVSSBjcmFzaGVzXHJcbiAgICAgIHJldHVybiB7IGRhdGE6IFtdLCBlcnJvcjogbnVsbCB9O1xyXG4gICAgfVxyXG5cclxuICAgIHJldHVybiB7IGRhdGEsIGVycm9yIH07XHJcbiAgfSBjYXRjaCAoZXJyb3IpIHtcclxuICAgIGNvbnNvbGUuZXJyb3IoXCJFcnJvciBpbiBnZXRBbGxVc2VyczpcIiwgZXJyb3IpO1xyXG4gICAgcmV0dXJuIHsgZGF0YTogW10sIGVycm9yOiBudWxsIH07XHJcbiAgfVxyXG59O1xyXG5cclxuZXhwb3J0IGNvbnN0IGdldFVzZXJzQnlSb2xlID0gYXN5bmMgKHJvbGU6IHN0cmluZykgPT4ge1xyXG4gIHRyeSB7XHJcbiAgICAvLyBUcnkgdG8gZ2V0IGZyb20gdXNlcnMgdGFibGVcclxuICAgIGNvbnN0IHsgZGF0YSwgZXJyb3IgfSA9IGF3YWl0IHN1cGFiYXNlXHJcbiAgICAgIC5mcm9tKFwidXNlcnNcIilcclxuICAgICAgLnNlbGVjdChcIipcIilcclxuICAgICAgLmVxKFwicm9sZVwiLCByb2xlKVxyXG4gICAgICAub3JkZXIoXCJmdWxsTmFtZVwiKTtcclxuXHJcbiAgICBpZiAoZXJyb3IpIHtcclxuICAgICAgY29uc29sZS5sb2coXCJVc2VycyB0YWJsZSBxdWVyeSBmYWlsZWQgZm9yIHJvbGU6XCIsIHJvbGUsIGVycm9yLm1lc3NhZ2UpO1xyXG4gICAgICAvLyBSZXR1cm4gZW1wdHkgYXJyYXkgaW5zdGVhZCBvZiBlcnJvciB0byBwcmV2ZW50IFVJIGNyYXNoZXNcclxuICAgICAgcmV0dXJuIHsgZGF0YTogW10sIGVycm9yOiBudWxsIH07XHJcbiAgICB9XHJcblxyXG4gICAgcmV0dXJuIHsgZGF0YSwgZXJyb3IgfTtcclxuICB9IGNhdGNoIChlcnJvcikge1xyXG4gICAgY29uc29sZS5lcnJvcihcIkVycm9yIGluIGdldFVzZXJzQnlSb2xlOlwiLCBlcnJvcik7XHJcbiAgICByZXR1cm4geyBkYXRhOiBbXSwgZXJyb3I6IG51bGwgfTtcclxuICB9XHJcbn07XHJcblxyXG4vLyBSb3V0ZSBNYW5hZ2VtZW50IFF1ZXJpZXNcclxuZXhwb3J0IGNvbnN0IGdldEFsbFJvdXRlcyA9IGFzeW5jICgpID0+IHtcclxuICBjb25zdCB7IGRhdGEsIGVycm9yIH0gPSBhd2FpdCBzdXBhYmFzZVxyXG4gICAgLmZyb20oXCJyb3V0ZXNcIilcclxuICAgIC5zZWxlY3QoXCIqXCIpXHJcbiAgICAub3JkZXIoXCJjcmVhdGVkX2F0XCIsIHsgYXNjZW5kaW5nOiBmYWxzZSB9KTtcclxuXHJcbiAgcmV0dXJuIHsgZGF0YSwgZXJyb3IgfTtcclxufTtcclxuXHJcbmV4cG9ydCBjb25zdCBjcmVhdGVSb3V0ZSA9IGFzeW5jIChyb3V0ZURhdGE6IHtcclxuICBuYW1lOiBzdHJpbmc7XHJcbiAgc3RhcnRfYWRkcmVzczogc3RyaW5nO1xyXG4gIGVuZF9hZGRyZXNzOiBzdHJpbmc7XHJcbiAgcGF0aD86IGFueTtcclxufSkgPT4ge1xyXG4gIHRyeSB7XHJcbiAgICAvLyBGb3IgUG9zdEdJUyBnZW9ncmFwaHkgY29sdW1ucywgd2UgbmVlZCB0byB1c2UgU1RfR2VvZ0Zyb21HZW9KU09OXHJcbiAgICAvLyBCdXQgc3VwYWJhc2UtanMgZG9lc24ndCBzdXBwb3J0IHRoaXMgZGlyZWN0bHksIHNvIHdlJ2xsIHVzZSBSUENcclxuICAgIGNvbnN0IHsgZGF0YSwgZXJyb3IgfSA9IGF3YWl0IHN1cGFiYXNlLnJwYyhcImluc2VydF9yb3V0ZVwiLCB7XHJcbiAgICAgIHBfbmFtZTogcm91dGVEYXRhLm5hbWUsXHJcbiAgICAgIHBfc3RhcnRfYWRkcmVzczogcm91dGVEYXRhLnN0YXJ0X2FkZHJlc3MsXHJcbiAgICAgIHBfZW5kX2FkZHJlc3M6IHJvdXRlRGF0YS5lbmRfYWRkcmVzcyxcclxuICAgICAgcF9wYXRoX2dlb2pzb246IHJvdXRlRGF0YS5wYXRoLFxyXG4gICAgfSk7XHJcblxyXG4gICAgaWYgKGVycm9yKSB7XHJcbiAgICAgIGNvbnNvbGUuZXJyb3IoXCJjcmVhdGVSb3V0ZSBlcnJvcjpcIiwgZXJyb3IpO1xyXG4gICAgICByZXR1cm4geyBkYXRhOiBudWxsLCBlcnJvciB9O1xyXG4gICAgfVxyXG5cclxuICAgIHJldHVybiB7IGRhdGEsIGVycm9yOiBudWxsIH07XHJcbiAgfSBjYXRjaCAoZXJyKSB7XHJcbiAgICBjb25zb2xlLmVycm9yKFwiY3JlYXRlUm91dGUgZXhjZXB0aW9uOlwiLCBlcnIpO1xyXG4gICAgcmV0dXJuIHsgZGF0YTogbnVsbCwgZXJyb3I6IHsgbWVzc2FnZTogU3RyaW5nKGVycikgfSBhcyBhbnkgfTtcclxuICB9XHJcbn07XHJcblxyXG5leHBvcnQgY29uc3QgdXBkYXRlUm91dGUgPSBhc3luYyAoXHJcbiAgcm91dGVJZDogc3RyaW5nLFxyXG4gIHJvdXRlRGF0YToge1xyXG4gICAgbmFtZT86IHN0cmluZztcclxuICAgIHN0YXJ0X2FkZHJlc3M/OiBzdHJpbmc7XHJcbiAgICBlbmRfYWRkcmVzcz86IHN0cmluZztcclxuICAgIHBhdGg/OiBhbnk7XHJcbiAgfVxyXG4pID0+IHtcclxuICB0cnkge1xyXG4gICAgLy8gVXNlIFJQQyBmdW5jdGlvbiBmb3IgUG9zdEdJUyBnZW9ncmFwaHkgaGFuZGxpbmdcclxuICAgIGNvbnN0IHsgZGF0YSwgZXJyb3IgfSA9IGF3YWl0IHN1cGFiYXNlLnJwYyhcInVwZGF0ZV9yb3V0ZVwiLCB7XHJcbiAgICAgIHBfcm91dGVfaWQ6IHJvdXRlSWQsXHJcbiAgICAgIHBfbmFtZTogcm91dGVEYXRhLm5hbWUgfHwgbnVsbCxcclxuICAgICAgcF9zdGFydF9hZGRyZXNzOiByb3V0ZURhdGEuc3RhcnRfYWRkcmVzcyB8fCBudWxsLFxyXG4gICAgICBwX2VuZF9hZGRyZXNzOiByb3V0ZURhdGEuZW5kX2FkZHJlc3MgfHwgbnVsbCxcclxuICAgICAgcF9wYXRoX2dlb2pzb246IHJvdXRlRGF0YS5wYXRoIHx8IG51bGwsXHJcbiAgICB9KTtcclxuXHJcbiAgICBpZiAoZXJyb3IpIHtcclxuICAgICAgY29uc29sZS5lcnJvcihcInVwZGF0ZVJvdXRlIGVycm9yOlwiLCBlcnJvcik7XHJcbiAgICAgIHJldHVybiB7IGRhdGE6IG51bGwsIGVycm9yIH07XHJcbiAgICB9XHJcblxyXG4gICAgcmV0dXJuIHsgZGF0YSwgZXJyb3I6IG51bGwgfTtcclxuICB9IGNhdGNoIChlcnIpIHtcclxuICAgIGNvbnNvbGUuZXJyb3IoXCJ1cGRhdGVSb3V0ZSBleGNlcHRpb246XCIsIGVycik7XHJcbiAgICByZXR1cm4geyBkYXRhOiBudWxsLCBlcnJvcjogeyBtZXNzYWdlOiBTdHJpbmcoZXJyKSB9IGFzIGFueSB9O1xyXG4gIH1cclxufTtcclxuXHJcbmV4cG9ydCBjb25zdCBkZWxldGVSb3V0ZSA9IGFzeW5jIChyb3V0ZUlkOiBzdHJpbmcpID0+IHtcclxuICB0cnkge1xyXG4gICAgY29uc3QgeyBkYXRhLCBlcnJvciB9ID0gYXdhaXQgc3VwYWJhc2VcclxuICAgICAgLmZyb20oXCJyb3V0ZXNcIilcclxuICAgICAgLmRlbGV0ZSgpXHJcbiAgICAgIC5lcShcImlkXCIsIHJvdXRlSWQpO1xyXG5cclxuICAgIGlmIChlcnJvcikge1xyXG4gICAgICBjb25zb2xlLmVycm9yKFwiZGVsZXRlUm91dGUgZXJyb3I6XCIsIGVycm9yKTtcclxuICAgICAgcmV0dXJuIHsgZGF0YTogbnVsbCwgZXJyb3IgfTtcclxuICAgIH1cclxuXHJcbiAgICByZXR1cm4geyBkYXRhLCBlcnJvcjogbnVsbCB9O1xyXG4gIH0gY2F0Y2ggKGVycikge1xyXG4gICAgY29uc29sZS5lcnJvcihcImRlbGV0ZVJvdXRlIGV4Y2VwdGlvbjpcIiwgZXJyKTtcclxuICAgIHJldHVybiB7IGRhdGE6IG51bGwsIGVycm9yOiB7IG1lc3NhZ2U6IFN0cmluZyhlcnIpIH0gYXMgYW55IH07XHJcbiAgfVxyXG59O1xyXG5cclxuLy8gQW5hbHl0aWNzIFF1ZXJpZXNcclxuZXhwb3J0IGNvbnN0IGdldFRyaXBBbmFseXRpY3MgPSBhc3luYyAoZGF5cyA9IDMwKSA9PiB7XHJcbiAgY29uc3QgeyBkYXRhLCBlcnJvciB9ID0gYXdhaXQgc3VwYWJhc2VcclxuICAgIC5mcm9tKFwidHJpcHNcIilcclxuICAgIC5zZWxlY3QoXHJcbiAgICAgIGBcclxuICAgICAgaWQsXHJcbiAgICAgIHN0YXR1cyxcclxuICAgICAgc3RhcnRlZF9hdCxcclxuICAgICAgZW5kZWRfYXQsXHJcbiAgICAgIGJ1c2VzIChcclxuICAgICAgICByb3V0ZXMgKFxyXG4gICAgICAgICAgbmFtZVxyXG4gICAgICAgIClcclxuICAgICAgKVxyXG4gICAgYFxyXG4gICAgKVxyXG4gICAgLmd0ZShcclxuICAgICAgXCJzdGFydGVkX2F0XCIsXHJcbiAgICAgIG5ldyBEYXRlKERhdGUubm93KCkgLSBkYXlzICogMjQgKiA2MCAqIDYwICogMTAwMCkudG9JU09TdHJpbmcoKVxyXG4gICAgKVxyXG4gICAgLm9yZGVyKFwic3RhcnRlZF9hdFwiLCB7IGFzY2VuZGluZzogZmFsc2UgfSk7XHJcblxyXG4gIHJldHVybiB7IGRhdGEsIGVycm9yIH07XHJcbn07XHJcblxyXG5leHBvcnQgY29uc3QgZ2V0Um91dGVVdGlsaXphdGlvbiA9IGFzeW5jICgpID0+IHtcclxuICBjb25zdCB7IGRhdGEsIGVycm9yIH0gPSBhd2FpdCBzdXBhYmFzZS5mcm9tKFwicm91dGVzXCIpLnNlbGVjdChgXHJcbiAgICAgIGlkLFxyXG4gICAgICBuYW1lLFxyXG4gICAgICBzdGFydF9hZGRyZXNzLFxyXG4gICAgICBlbmRfYWRkcmVzcyxcclxuICAgICAgYnVzZXMgKFxyXG4gICAgICAgIGlkLFxyXG4gICAgICAgIHBsYXRlX251bWJlcixcclxuICAgICAgICBzdGF0dXMsXHJcbiAgICAgICAgdHJpcHMgKFxyXG4gICAgICAgICAgaWQsXHJcbiAgICAgICAgICBzdGF0dXMsXHJcbiAgICAgICAgICBzdGFydGVkX2F0XHJcbiAgICAgICAgKVxyXG4gICAgICApXHJcbiAgICBgKTtcclxuXHJcbiAgcmV0dXJuIHsgZGF0YSwgZXJyb3IgfTtcclxufTtcclxuXHJcbmV4cG9ydCBjb25zdCBnZXRUcmF2ZWxIaXN0b3J5ID0gYXN5bmMgKGxpbWl0ID0gMTAwKSA9PiB7XHJcbiAgLy8gVHJ5IHRvIGdldCBmcm9tIHRyYXZlbF9oaXN0b3J5X2NvbW11dGVyIHRhYmxlIHdpdGggcHJvcGVyIGpvaW5cclxuICBjb25zdCB7IGRhdGE6IGNvbW11dGVyRGF0YSwgZXJyb3I6IGNvbW11dGVyRXJyb3IgfSA9IGF3YWl0IHN1cGFiYXNlXHJcbiAgICAuZnJvbShcInRyYXZlbF9oaXN0b3J5X2NvbW11dGVyXCIpXHJcbiAgICAuc2VsZWN0KFxyXG4gICAgICBgXHJcbiAgICAgIGlkLFxyXG4gICAgICBzdGFydF9sb2NhdGlvbl9uYW1lLFxyXG4gICAgICBlbmRfbG9jYXRpb25fbmFtZSxcclxuICAgICAgdHJhdmVsX2RhdGUsXHJcbiAgICAgIHJvdXRlX25hbWUsXHJcbiAgICAgIHN0YXR1cyxcclxuICAgICAgdXNlcjp1c2VycyAoXHJcbiAgICAgICAgaWQsXHJcbiAgICAgICAgZnVsbE5hbWVcclxuICAgICAgKVxyXG4gICAgYFxyXG4gICAgKVxyXG4gICAgLm9yZGVyKFwidHJhdmVsX2RhdGVcIiwgeyBhc2NlbmRpbmc6IGZhbHNlIH0pXHJcbiAgICAubGltaXQobGltaXQpO1xyXG5cclxuICAvLyBJZiBzdWNjZXNzZnVsLCByZXR1cm4gdGhlIGRhdGFcclxuICBpZiAoY29tbXV0ZXJEYXRhICYmICFjb21tdXRlckVycm9yKSB7XHJcbiAgICByZXR1cm4geyBkYXRhOiBjb21tdXRlckRhdGEsIGVycm9yOiBudWxsIH07XHJcbiAgfVxyXG5cclxuICAvLyBJZiB0cmF2ZWxfaGlzdG9yeV9jb21tdXRlciB0YWJsZSBkb2Vzbid0IGV4aXN0LCBmYWxsIGJhY2sgdG8gdHJpcHMgdGFibGVcclxuICBpZiAoY29tbXV0ZXJFcnJvciAmJiBjb21tdXRlckVycm9yLmNvZGUgPT09IFwiUEdSU1QyMDBcIikge1xyXG4gICAgY29uc3QgeyBkYXRhOiB0cmlwc0RhdGEsIGVycm9yOiB0cmlwc0Vycm9yIH0gPSBhd2FpdCBzdXBhYmFzZVxyXG4gICAgICAuZnJvbShcInRyaXBzXCIpXHJcbiAgICAgIC5zZWxlY3QoXHJcbiAgICAgICAgYFxyXG4gICAgICAgIGlkLFxyXG4gICAgICAgIHN0YXR1cyxcclxuICAgICAgICBzdGFydGVkX2F0LFxyXG4gICAgICAgIGVuZGVkX2F0LFxyXG4gICAgICAgIGJ1c2VzIChcclxuICAgICAgICAgIHJvdXRlcyAoXHJcbiAgICAgICAgICAgIG5hbWUsXHJcbiAgICAgICAgICAgIHN0YXJ0X2FkZHJlc3MsXHJcbiAgICAgICAgICAgIGVuZF9hZGRyZXNzXHJcbiAgICAgICAgICApXHJcbiAgICAgICAgKSxcclxuICAgICAgICBkcml2ZXI6dXNlcnMhdHJpcHNfZHJpdmVyX2lkX2ZrZXkgKFxyXG4gICAgICAgICAgaWQsXHJcbiAgICAgICAgICBmdWxsTmFtZVxyXG4gICAgICAgIClcclxuICAgICAgYFxyXG4gICAgICApXHJcbiAgICAgIC5pbihcInN0YXR1c1wiLCBbXCJjb21wbGV0ZWRcIiwgXCJjYW5jZWxsZWRcIl0pXHJcbiAgICAgIC5vcmRlcihcInN0YXJ0ZWRfYXRcIiwgeyBhc2NlbmRpbmc6IGZhbHNlIH0pXHJcbiAgICAgIC5saW1pdChsaW1pdCk7XHJcblxyXG4gICAgaWYgKHRyaXBzRXJyb3IpIHtcclxuICAgICAgcmV0dXJuIHsgZGF0YTogbnVsbCwgZXJyb3I6IHRyaXBzRXJyb3IgfTtcclxuICAgIH1cclxuXHJcbiAgICAvLyBUcmFuc2Zvcm0gdHJpcHMgZGF0YSB0byBtYXRjaCBleHBlY3RlZCBmb3JtYXRcclxuICAgIGNvbnN0IHRyYW5zZm9ybWVkRGF0YSA9XHJcbiAgICAgIHRyaXBzRGF0YT8ubWFwKCh0cmlwKSA9PiAoe1xyXG4gICAgICAgIGlkOiB0cmlwLmlkLFxyXG4gICAgICAgIHN0YXJ0X2xvY2F0aW9uX25hbWU6XHJcbiAgICAgICAgICAodHJpcC5idXNlcyBhcyBhbnkpPy5yb3V0ZXM/LnN0YXJ0X2FkZHJlc3MgfHwgXCJVbmtub3duXCIsXHJcbiAgICAgICAgZW5kX2xvY2F0aW9uX25hbWU6XHJcbiAgICAgICAgICAodHJpcC5idXNlcyBhcyBhbnkpPy5yb3V0ZXM/LmVuZF9hZGRyZXNzIHx8IFwiVW5rbm93blwiLFxyXG4gICAgICAgIHRyYXZlbF9kYXRlOlxyXG4gICAgICAgICAgdHJpcC5zdGFydGVkX2F0Py5zcGxpdChcIlRcIilbMF0gfHxcclxuICAgICAgICAgIG5ldyBEYXRlKCkudG9JU09TdHJpbmcoKS5zcGxpdChcIlRcIilbMF0sXHJcbiAgICAgICAgcm91dGVfbmFtZTogKHRyaXAuYnVzZXMgYXMgYW55KT8ucm91dGVzPy5uYW1lIHx8IFwiVW5rbm93biBSb3V0ZVwiLFxyXG4gICAgICAgIHN0YXR1czogdHJpcC5zdGF0dXMsXHJcbiAgICAgICAgY3JlYXRlZF9hdDogdHJpcC5zdGFydGVkX2F0LFxyXG4gICAgICAgIHVzZXI6IHRyaXAuZHJpdmVyLFxyXG4gICAgICB9KSkgfHwgW107XHJcblxyXG4gICAgcmV0dXJuIHsgZGF0YTogdHJhbnNmb3JtZWREYXRhLCBlcnJvcjogbnVsbCB9O1xyXG4gIH1cclxuXHJcbiAgcmV0dXJuIHsgZGF0YTogY29tbXV0ZXJEYXRhLCBlcnJvcjogY29tbXV0ZXJFcnJvciB9O1xyXG59O1xyXG5cclxuLy8gVXBkYXRlIE9wZXJhdGlvbnNcclxuZXhwb3J0IGNvbnN0IHVwZGF0ZUJ1c1N0YXR1cyA9IGFzeW5jIChcclxuICBidXNJZDogc3RyaW5nLFxyXG4gIHN0YXR1czogXCJhY3RpdmVcIiB8IFwiaW5hY3RpdmVcIlxyXG4pID0+IHtcclxuICBjb25zdCB7IGRhdGEsIGVycm9yIH0gPSBhd2FpdCBzdXBhYmFzZVxyXG4gICAgLmZyb20oXCJidXNlc1wiKVxyXG4gICAgLnVwZGF0ZSh7IHN0YXR1cywgdXBkYXRlZF9hdDogbmV3IERhdGUoKS50b0lTT1N0cmluZygpIH0pXHJcbiAgICAuZXEoXCJpZFwiLCBidXNJZClcclxuICAgIC5zZWxlY3QoKTtcclxuXHJcbiAgcmV0dXJuIHsgZGF0YSwgZXJyb3IgfTtcclxufTtcclxuXHJcbmV4cG9ydCBjb25zdCBhc3NpZ25Ecml2ZXJUb0J1cyA9IGFzeW5jIChidXNJZDogc3RyaW5nLCBkcml2ZXJJZDogc3RyaW5nKSA9PiB7XHJcbiAgY29uc3QgeyBkYXRhLCBlcnJvciB9ID0gYXdhaXQgc3VwYWJhc2VcclxuICAgIC5mcm9tKFwiYnVzZXNcIilcclxuICAgIC51cGRhdGUoeyBkcml2ZXJfaWQ6IGRyaXZlcklkLCB1cGRhdGVkX2F0OiBuZXcgRGF0ZSgpLnRvSVNPU3RyaW5nKCkgfSlcclxuICAgIC5lcShcImlkXCIsIGJ1c0lkKVxyXG4gICAgLnNlbGVjdCgpO1xyXG5cclxuICByZXR1cm4geyBkYXRhLCBlcnJvciB9O1xyXG59O1xyXG5cclxuZXhwb3J0IGNvbnN0IHVwZGF0ZUJ1c0Fzc2lnbm1lbnQgPSBhc3luYyAoXHJcbiAgYnVzSWQ6IHN0cmluZyxcclxuICB1cGRhdGVzOiB7IGRyaXZlcklkPzogc3RyaW5nOyBjb25kdWN0b3JJZD86IHN0cmluZyB9XHJcbikgPT4ge1xyXG4gIGNvbnN0IHsgZHJpdmVySWQsIGNvbmR1Y3RvcklkIH0gPSB1cGRhdGVzO1xyXG4gIGNvbnN0IHVwZGF0ZVBheWxvYWQ6IGFueSA9IHsgdXBkYXRlZF9hdDogbmV3IERhdGUoKS50b0lTT1N0cmluZygpIH07XHJcbiAgaWYgKGRyaXZlcklkICE9PSB1bmRlZmluZWQpIHVwZGF0ZVBheWxvYWQuZHJpdmVyX2lkID0gZHJpdmVySWQ7XHJcbiAgaWYgKGNvbmR1Y3RvcklkICE9PSB1bmRlZmluZWQpIHVwZGF0ZVBheWxvYWQuY29uZHVjdG9yX2lkID0gY29uZHVjdG9ySWQ7XHJcblxyXG4gIGNvbnN0IHsgZGF0YSwgZXJyb3IgfSA9IGF3YWl0IHN1cGFiYXNlXHJcbiAgICAuZnJvbShcImJ1c2VzXCIpXHJcbiAgICAudXBkYXRlKHVwZGF0ZVBheWxvYWQpXHJcbiAgICAuZXEoXCJpZFwiLCBidXNJZClcclxuICAgIC5zZWxlY3QoKTtcclxuXHJcbiAgcmV0dXJuIHsgZGF0YSwgZXJyb3IgfTtcclxufTtcclxuXHJcbmV4cG9ydCBjb25zdCB1cGRhdGVUcmlwU3RhdHVzID0gYXN5bmMgKFxyXG4gIHRyaXBJZDogc3RyaW5nLFxyXG4gIHN0YXR1czogc3RyaW5nLFxyXG4gIGN1cnJlbnRMb2NhdGlvbj86IGFueVxyXG4pID0+IHtcclxuICBjb25zdCB1cGRhdGVEYXRhOiBhbnkgPSB7XHJcbiAgICBzdGF0dXMsXHJcbiAgICB1cGRhdGVkX2F0OiBuZXcgRGF0ZSgpLnRvSVNPU3RyaW5nKCksXHJcbiAgfTtcclxuXHJcbiAgaWYgKGN1cnJlbnRMb2NhdGlvbikge1xyXG4gICAgdXBkYXRlRGF0YS5jdXJyZW50X2xvY2F0aW9uID0gY3VycmVudExvY2F0aW9uO1xyXG4gIH1cclxuXHJcbiAgaWYgKHN0YXR1cyA9PT0gXCJjb21wbGV0ZWRcIikge1xyXG4gICAgdXBkYXRlRGF0YS5lbmRlZF9hdCA9IG5ldyBEYXRlKCkudG9JU09TdHJpbmcoKTtcclxuICB9IGVsc2UgaWYgKHN0YXR1cyA9PT0gXCJjYW5jZWxsZWRcIikge1xyXG4gICAgdXBkYXRlRGF0YS5jYW5jZWxsZWRfYXQgPSBuZXcgRGF0ZSgpLnRvSVNPU3RyaW5nKCk7XHJcbiAgfVxyXG5cclxuICBjb25zdCB7IGRhdGEsIGVycm9yIH0gPSBhd2FpdCBzdXBhYmFzZVxyXG4gICAgLmZyb20oXCJ0cmlwc1wiKVxyXG4gICAgLnVwZGF0ZSh1cGRhdGVEYXRhKVxyXG4gICAgLmVxKFwiaWRcIiwgdHJpcElkKVxyXG4gICAgLnNlbGVjdCgpO1xyXG5cclxuICByZXR1cm4geyBkYXRhLCBlcnJvciB9O1xyXG59O1xyXG4iXSwibmFtZXMiOlsic3VwYWJhc2UiLCJnZXREYXNoYm9hcmRNZXRyaWNzIiwiY291bnQiLCJhY3RpdmVCdXNlcyIsIm9uZ29pbmdUcmlwcyIsInRvdGFsUm91dGVzIiwidG90YWxVc2VycyIsInRvZGF5VHJpcHMiLCJjb21wbGV0ZWRUcmlwcyIsImNhbmNlbGxlZFRyaXBzIiwiUHJvbWlzZSIsImFsbCIsImZyb20iLCJzZWxlY3QiLCJoZWFkIiwiZXEiLCJndGUiLCJEYXRlIiwidG9JU09TdHJpbmciLCJzcGxpdCIsImRhdGEiLCJwYXNzZW5nZXJzRGF0YSIsInRvdGFsUGFzc2VuZ2VycyIsImxlbmd0aCIsImdldEZsZWV0U3RhdHVzIiwiZXJyb3IiLCJvcmRlciIsImdldEFsbEJ1c2VzIiwiZ2V0RHJpdmVycyIsImluIiwiZ2V0Q29uZHVjdG9ycyIsImdldEFjdGl2ZVRyaXBzIiwiYXNjZW5kaW5nIiwiZ2V0VHJpcEhpc3RvcnkiLCJsaW1pdCIsImdldEFsbFVzZXJzIiwiY29uc29sZSIsImxvZyIsIm1lc3NhZ2UiLCJnZXRVc2Vyc0J5Um9sZSIsInJvbGUiLCJnZXRBbGxSb3V0ZXMiLCJjcmVhdGVSb3V0ZSIsInJvdXRlRGF0YSIsInJwYyIsInBfbmFtZSIsIm5hbWUiLCJwX3N0YXJ0X2FkZHJlc3MiLCJzdGFydF9hZGRyZXNzIiwicF9lbmRfYWRkcmVzcyIsImVuZF9hZGRyZXNzIiwicF9wYXRoX2dlb2pzb24iLCJwYXRoIiwiZXJyIiwiU3RyaW5nIiwidXBkYXRlUm91dGUiLCJyb3V0ZUlkIiwicF9yb3V0ZV9pZCIsImRlbGV0ZVJvdXRlIiwiZGVsZXRlIiwiZ2V0VHJpcEFuYWx5dGljcyIsImRheXMiLCJub3ciLCJnZXRSb3V0ZVV0aWxpemF0aW9uIiwiZ2V0VHJhdmVsSGlzdG9yeSIsImNvbW11dGVyRGF0YSIsImNvbW11dGVyRXJyb3IiLCJjb2RlIiwidHJpcHNEYXRhIiwidHJpcHNFcnJvciIsInRyYW5zZm9ybWVkRGF0YSIsIm1hcCIsInRyaXAiLCJpZCIsInN0YXJ0X2xvY2F0aW9uX25hbWUiLCJidXNlcyIsInJvdXRlcyIsImVuZF9sb2NhdGlvbl9uYW1lIiwidHJhdmVsX2RhdGUiLCJzdGFydGVkX2F0Iiwicm91dGVfbmFtZSIsInN0YXR1cyIsImNyZWF0ZWRfYXQiLCJ1c2VyIiwiZHJpdmVyIiwidXBkYXRlQnVzU3RhdHVzIiwiYnVzSWQiLCJ1cGRhdGUiLCJ1cGRhdGVkX2F0IiwiYXNzaWduRHJpdmVyVG9CdXMiLCJkcml2ZXJJZCIsImRyaXZlcl9pZCIsInVwZGF0ZUJ1c0Fzc2lnbm1lbnQiLCJ1cGRhdGVzIiwiY29uZHVjdG9ySWQiLCJ1cGRhdGVQYXlsb2FkIiwidW5kZWZpbmVkIiwiY29uZHVjdG9yX2lkIiwidXBkYXRlVHJpcFN0YXR1cyIsInRyaXBJZCIsImN1cnJlbnRMb2NhdGlvbiIsInVwZGF0ZURhdGEiLCJjdXJyZW50X2xvY2F0aW9uIiwiZW5kZWRfYXQiLCJjYW5jZWxsZWRfYXQiXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(app-pages-browser)/./lib/queries.ts\n"));

/***/ })

});