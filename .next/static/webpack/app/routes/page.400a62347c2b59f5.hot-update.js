"use strict";
/*
 * ATTENTION: An "eval-source-map" devtool has been used.
 * This devtool is neither made for production nor for readable output files.
 * It uses "eval()" calls to create a separate source file with attached SourceMaps in the browser devtools.
 * If you are trying to read the output file, select a different devtool (https://webpack.js.org/configuration/devtool/)
 * or disable the default devtool with "devtool: false".
 * If you are looking for production-ready output files, see mode: "production" (https://webpack.js.org/configuration/mode/).
 */
self["webpackHotUpdate_N_E"]("app/routes/page",{

/***/ "(app-pages-browser)/./lib/queries.ts":
/*!************************!*\
  !*** ./lib/queries.ts ***!
  \************************/
/***/ (function(module, __webpack_exports__, __webpack_require__) {

eval(__webpack_require__.ts("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   assignDriverToBus: function() { return /* binding */ assignDriverToBus; },\n/* harmony export */   createRoute: function() { return /* binding */ createRoute; },\n/* harmony export */   deleteRoute: function() { return /* binding */ deleteRoute; },\n/* harmony export */   getActiveTrips: function() { return /* binding */ getActiveTrips; },\n/* harmony export */   getAllBuses: function() { return /* binding */ getAllBuses; },\n/* harmony export */   getAllRoutes: function() { return /* binding */ getAllRoutes; },\n/* harmony export */   getAllUsers: function() { return /* binding */ getAllUsers; },\n/* harmony export */   getConductors: function() { return /* binding */ getConductors; },\n/* harmony export */   getDashboardMetrics: function() { return /* binding */ getDashboardMetrics; },\n/* harmony export */   getDrivers: function() { return /* binding */ getDrivers; },\n/* harmony export */   getFleetStatus: function() { return /* binding */ getFleetStatus; },\n/* harmony export */   getRouteUtilization: function() { return /* binding */ getRouteUtilization; },\n/* harmony export */   getTravelHistory: function() { return /* binding */ getTravelHistory; },\n/* harmony export */   getTripAnalytics: function() { return /* binding */ getTripAnalytics; },\n/* harmony export */   getTripHistory: function() { return /* binding */ getTripHistory; },\n/* harmony export */   getUsersByRole: function() { return /* binding */ getUsersByRole; },\n/* harmony export */   updateBusAssignment: function() { return /* binding */ updateBusAssignment; },\n/* harmony export */   updateBusStatus: function() { return /* binding */ updateBusStatus; },\n/* harmony export */   updateRoute: function() { return /* binding */ updateRoute; },\n/* harmony export */   updateTripStatus: function() { return /* binding */ updateTripStatus; }\n/* harmony export */ });\n/* harmony import */ var _supabase__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./supabase */ \"(app-pages-browser)/./lib/supabase.ts\");\n\n// Dashboard Metrics Queries\nconst getDashboardMetrics = async ()=>{\n    const [{ count: activeBuses }, { count: ongoingTrips }, { count: totalRoutes }, { count: totalUsers }, { count: todayTrips }, { count: completedTrips }, { count: cancelledTrips }] = await Promise.all([\n        _supabase__WEBPACK_IMPORTED_MODULE_0__.supabase.from(\"buses\").select(\"*\", {\n            count: \"exact\",\n            head: true\n        }).eq(\"status\", \"active\"),\n        _supabase__WEBPACK_IMPORTED_MODULE_0__.supabase.from(\"trips\").select(\"*\", {\n            count: \"exact\",\n            head: true\n        }).eq(\"status\", \"ongoing\"),\n        _supabase__WEBPACK_IMPORTED_MODULE_0__.supabase.from(\"routes\").select(\"*\", {\n            count: \"exact\",\n            head: true\n        }),\n        _supabase__WEBPACK_IMPORTED_MODULE_0__.supabase.from(\"users\").select(\"*\", {\n            count: \"exact\",\n            head: true\n        }),\n        _supabase__WEBPACK_IMPORTED_MODULE_0__.supabase.from(\"trips\").select(\"*\", {\n            count: \"exact\",\n            head: true\n        }).gte(\"started_at\", new Date().toISOString().split(\"T\")[0]),\n        _supabase__WEBPACK_IMPORTED_MODULE_0__.supabase.from(\"trips\").select(\"*\", {\n            count: \"exact\",\n            head: true\n        }).eq(\"status\", \"completed\"),\n        _supabase__WEBPACK_IMPORTED_MODULE_0__.supabase.from(\"trips\").select(\"*\", {\n            count: \"exact\",\n            head: true\n        }).eq(\"status\", \"cancelled\")\n    ]);\n    // Get total passengers from trip_passengers\n    const { data: passengersData } = await _supabase__WEBPACK_IMPORTED_MODULE_0__.supabase.from(\"trip_passengers\").select(\"*\", {\n        count: \"exact\",\n        head: true\n    }).eq(\"status\", \"boarded\");\n    return {\n        activeBuses: activeBuses || 0,\n        ongoingTrips: ongoingTrips || 0,\n        totalRoutes: totalRoutes || 0,\n        totalPassengers: (passengersData === null || passengersData === void 0 ? void 0 : passengersData.length) || 0,\n        todayTrips: todayTrips || 0,\n        totalUsers: totalUsers || 0,\n        completedTrips: completedTrips || 0,\n        cancelledTrips: cancelledTrips || 0\n    };\n};\n// Fleet Management Queries\nconst getFleetStatus = async ()=>{\n    const { data, error } = await _supabase__WEBPACK_IMPORTED_MODULE_0__.supabase.from(\"buses\").select(\"\\n      id,\\n      plate_number,\\n      capacity,\\n      passengers,\\n      status,\\n      route_id,\\n      driver_id,\\n      routes (\\n        id,\\n        name,\\n        start_address,\\n        end_address\\n      ),\\n      driver:users!fk_driver (\\n        id,\\n        fullName,\\n        contact_number\\n      ),\\n      trips!inner (\\n        id,\\n        status,\\n        current_location\\n      )\\n    \").eq(\"trips.status\", \"ongoing\").order(\"plate_number\");\n    return {\n        data,\n        error\n    };\n};\nconst getAllBuses = async ()=>{\n    const { data, error } = await _supabase__WEBPACK_IMPORTED_MODULE_0__.supabase.from(\"buses\").select(\"\\n      id,\\n      plate_number,\\n      capacity,\\n      passengers,\\n      status,\\n      route_id,\\n      driver_id,\\n      conductor_id,\\n      routes (\\n        id,\\n        name,\\n        start_address,\\n        end_address\\n      ),\\n      driver:users!fk_driver (\\n        id,\\n        fullName,\\n        contact_number,\\n        license_number,\\n        license_expiry\\n      ),\\n      conductor:users!buses_conductor_id_fkey (\\n        id,\\n        fullName,\\n        contact_number\\n      )\\n    \").order(\"plate_number\");\n    return {\n        data,\n        error\n    };\n};\nconst getDrivers = async ()=>{\n    const { data, error } = await _supabase__WEBPACK_IMPORTED_MODULE_0__.supabase.from(\"users\").select(\"*\").in(\"role\", [\n        \"driver\",\n        \"Driver\"\n    ]).order(\"fullName\");\n    return {\n        data,\n        error\n    };\n};\nconst getConductors = async ()=>{\n    const { data, error } = await _supabase__WEBPACK_IMPORTED_MODULE_0__.supabase.from(\"users\").select(\"*\").in(\"role\", [\n        \"conductor\",\n        \"Conductor\"\n    ]).order(\"fullName\");\n    return {\n        data,\n        error\n    };\n};\n// Trip Management Queries\nconst getActiveTrips = async ()=>{\n    const { data, error } = await _supabase__WEBPACK_IMPORTED_MODULE_0__.supabase.from(\"trips\").select(\"\\n      id,\\n      status,\\n      current_location,\\n      started_at,\\n      buses (\\n        id,\\n        plate_number,\\n        capacity,\\n        routes (\\n          id,\\n          name,\\n          start_address,\\n          end_address\\n        )\\n      ),\\n      driver:users!trips_driver_id_fkey (\\n        id,\\n        fullName,\\n        contact_number\\n      ),\\n      trip_passengers (\\n        id,\\n        status,\\n        boarded_at,\\n        commuter:users (\\n          id,\\n          fullName\\n        )\\n      )\\n    \").in(\"status\", [\n        \"waiting\",\n        \"ongoing\"\n    ]).order(\"started_at\", {\n        ascending: false\n    });\n    return {\n        data,\n        error\n    };\n};\nconst getTripHistory = async function() {\n    let limit = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : 50;\n    const { data, error } = await _supabase__WEBPACK_IMPORTED_MODULE_0__.supabase.from(\"trips\").select(\"\\n      id,\\n      status,\\n      started_at,\\n      ended_at,\\n      cancelled_at,\\n      cancellation_reason,\\n      buses (\\n        id,\\n        plate_number,\\n        routes (\\n          id,\\n          name\\n        )\\n      ),\\n      driver:users!trips_driver_id_fkey (\\n        id,\\n        fullName\\n      ),\\n      trip_passengers (\\n        id,\\n        status\\n      )\\n    \").in(\"status\", [\n        \"completed\",\n        \"cancelled\"\n    ]).order(\"started_at\", {\n        ascending: false\n    }).limit(limit);\n    return {\n        data,\n        error\n    };\n};\n// User Management\nconst getAllUsers = async ()=>{\n    try {\n        // Try to get from users table\n        const { data, error } = await _supabase__WEBPACK_IMPORTED_MODULE_0__.supabase.from(\"users\").select(\"*\").order(\"updated_at\", {\n            ascending: false\n        });\n        if (error) {\n            console.log(\"Users table query failed:\", error.message);\n            // Return empty array instead of error to prevent UI crashes\n            return {\n                data: [],\n                error: null\n            };\n        }\n        return {\n            data,\n            error\n        };\n    } catch (error) {\n        console.error(\"Error in getAllUsers:\", error);\n        return {\n            data: [],\n            error: null\n        };\n    }\n};\nconst getUsersByRole = async (role)=>{\n    try {\n        // Try to get from users table\n        const { data, error } = await _supabase__WEBPACK_IMPORTED_MODULE_0__.supabase.from(\"users\").select(\"*\").eq(\"role\", role).order(\"fullName\");\n        if (error) {\n            console.log(\"Users table query failed for role:\", role, error.message);\n            // Return empty array instead of error to prevent UI crashes\n            return {\n                data: [],\n                error: null\n            };\n        }\n        return {\n            data,\n            error\n        };\n    } catch (error) {\n        console.error(\"Error in getUsersByRole:\", error);\n        return {\n            data: [],\n            error: null\n        };\n    }\n};\n// Route Management Queries\nconst getAllRoutes = async ()=>{\n    const { data, error } = await _supabase__WEBPACK_IMPORTED_MODULE_0__.supabase.from(\"routes\").select(\"*\").order(\"created_at\", {\n        ascending: false\n    });\n    return {\n        data,\n        error\n    };\n};\nconst createRoute = async (routeData)=>{\n    try {\n        // For PostGIS geography columns, we need to use ST_GeogFromGeoJSON\n        // But supabase-js doesn't support this directly, so we'll use RPC\n        const { data, error } = await _supabase__WEBPACK_IMPORTED_MODULE_0__.supabase.rpc(\"insert_route\", {\n            p_name: routeData.name,\n            p_start_address: routeData.start_address,\n            p_end_address: routeData.end_address,\n            p_path_geojson: routeData.path\n        });\n        if (error) {\n            console.error(\"createRoute error:\", error);\n            return {\n                data: null,\n                error\n            };\n        }\n        return {\n            data,\n            error: null\n        };\n    } catch (err) {\n        console.error(\"createRoute exception:\", err);\n        return {\n            data: null,\n            error: {\n                message: String(err)\n            }\n        };\n    }\n};\nconst updateRoute = async (routeId, routeData)=>{\n    try {\n        // Use RPC function for PostGIS geography handling\n        const { data, error } = await _supabase__WEBPACK_IMPORTED_MODULE_0__.supabase.rpc(\"update_route\", {\n            p_route_id: routeId,\n            p_name: routeData.name || null,\n            p_start_address: routeData.start_address || null,\n            p_end_address: routeData.end_address || null,\n            p_path_geojson: routeData.path || null\n        });\n        if (error) {\n            console.error(\"updateRoute error:\", error);\n            return {\n                data: null,\n                error\n            };\n        }\n        return {\n            data,\n            error: null\n        };\n    } catch (err) {\n        console.error(\"updateRoute exception:\", err);\n        return {\n            data: null,\n            error: {\n                message: String(err)\n            }\n        };\n    }\n};\nconst deleteRoute = async (routeId)=>{\n    try {\n        var _session_user, _session_user1;\n        // Debug: Log current auth user and their role\n        const { data: { session } } = await _supabase__WEBPACK_IMPORTED_MODULE_0__.supabase.auth.getSession();\n        console.log(\"deleteRoute - Current auth user ID:\", session === null || session === void 0 ? void 0 : (_session_user = session.user) === null || _session_user === void 0 ? void 0 : _session_user.id);\n        if (session === null || session === void 0 ? void 0 : (_session_user1 = session.user) === null || _session_user1 === void 0 ? void 0 : _session_user1.id) {\n            const { data: userData } = await _supabase__WEBPACK_IMPORTED_MODULE_0__.supabase.from(\"users\").select(\"id, fullName, role\").eq(\"id\", session.user.id).single();\n            console.log(\"deleteRoute - User in users table:\", userData);\n        } else {\n            console.error(\"deleteRoute - No authenticated session found!\");\n        }\n        // Add .select() to get back the deleted rows - this helps verify deletion actually happened\n        const { data, error } = await _supabase__WEBPACK_IMPORTED_MODULE_0__.supabase.from(\"routes\").delete().eq(\"id\", routeId).select();\n        if (error) {\n            console.error(\"deleteRoute error:\", error);\n            return {\n                data: null,\n                error\n            };\n        }\n        // Check if the delete actually affected any rows\n        // When RLS policies block deletion, Supabase returns empty data without an error\n        if (!data || data.length === 0) {\n            console.error(\"deleteRoute: No rows were deleted. This may be due to RLS policies or the route not existing.\");\n            return {\n                data: null,\n                error: {\n                    message: \"Delete failed: No rows were affected. Please check database permissions (RLS) or ensure the route exists.\",\n                    code: \"NO_ROWS_AFFECTED\"\n                }\n            };\n        }\n        console.log(\"deleteRoute: Successfully deleted route:\", data);\n        return {\n            data,\n            error: null\n        };\n    } catch (err) {\n        console.error(\"deleteRoute exception:\", err);\n        return {\n            data: null,\n            error: {\n                message: String(err)\n            }\n        };\n    }\n};\n// Analytics Queries\nconst getTripAnalytics = async function() {\n    let days = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : 30;\n    const dateThreshold = new Date(Date.now() - days * 24 * 60 * 60 * 1000).toISOString();\n    console.log(\"getTripAnalytics: Fetching trips from last\", days, \"days, since:\", dateThreshold);\n    // Fetch all trips - some may have started_at as null (cancelled before starting)\n    // Also filter by updated_at as a fallback for trips that were cancelled before starting\n    const { data, error } = await _supabase__WEBPACK_IMPORTED_MODULE_0__.supabase.from(\"trips\").select(\"\\n      id,\\n      status,\\n      started_at,\\n      ended_at,\\n      cancelled_at,\\n      updated_at,\\n      buses (\\n        routes (\\n          name\\n        )\\n      )\\n    \").or(\"started_at.gte.\".concat(dateThreshold, \",updated_at.gte.\").concat(dateThreshold)).order(\"updated_at\", {\n        ascending: false\n    });\n    console.log(\"getTripAnalytics result:\", {\n        count: (data === null || data === void 0 ? void 0 : data.length) || 0,\n        error,\n        statuses: data === null || data === void 0 ? void 0 : data.reduce((acc, trip)=>{\n            acc[trip.status] = (acc[trip.status] || 0) + 1;\n            return acc;\n        }, {})\n    });\n    return {\n        data,\n        error\n    };\n};\nconst getRouteUtilization = async ()=>{\n    const { data, error } = await _supabase__WEBPACK_IMPORTED_MODULE_0__.supabase.from(\"routes\").select(\"\\n      id,\\n      name,\\n      start_address,\\n      end_address,\\n      buses (\\n        id,\\n        plate_number,\\n        status,\\n        trips (\\n          id,\\n          status,\\n          started_at\\n        )\\n      )\\n    \");\n    return {\n        data,\n        error\n    };\n};\nconst getTravelHistory = async function() {\n    let limit = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : 100;\n    // Try to get from travel_history_commuter table with proper join\n    const { data: commuterData, error: commuterError } = await _supabase__WEBPACK_IMPORTED_MODULE_0__.supabase.from(\"travel_history_commuter\").select(\"\\n      id,\\n      start_location_name,\\n      end_location_name,\\n      travel_date,\\n      route_name,\\n      status,\\n      user:users (\\n        id,\\n        fullName\\n      )\\n    \").order(\"travel_date\", {\n        ascending: false\n    }).limit(limit);\n    // If successful, return the data\n    if (commuterData && !commuterError) {\n        return {\n            data: commuterData,\n            error: null\n        };\n    }\n    // If travel_history_commuter table doesn't exist, fall back to trips table\n    if (commuterError && commuterError.code === \"PGRST200\") {\n        const { data: tripsData, error: tripsError } = await _supabase__WEBPACK_IMPORTED_MODULE_0__.supabase.from(\"trips\").select(\"\\n        id,\\n        status,\\n        started_at,\\n        ended_at,\\n        buses (\\n          routes (\\n            name,\\n            start_address,\\n            end_address\\n          )\\n        ),\\n        driver:users!trips_driver_id_fkey (\\n          id,\\n          fullName\\n        )\\n      \").in(\"status\", [\n            \"completed\",\n            \"cancelled\"\n        ]).order(\"started_at\", {\n            ascending: false\n        }).limit(limit);\n        if (tripsError) {\n            return {\n                data: null,\n                error: tripsError\n            };\n        }\n        // Transform trips data to match expected format\n        const transformedData = (tripsData === null || tripsData === void 0 ? void 0 : tripsData.map((trip)=>{\n            var _trip_buses_routes, _trip_buses, _trip_buses_routes1, _trip_buses1, _trip_started_at, _trip_buses_routes2, _trip_buses2;\n            return {\n                id: trip.id,\n                start_location_name: ((_trip_buses = trip.buses) === null || _trip_buses === void 0 ? void 0 : (_trip_buses_routes = _trip_buses.routes) === null || _trip_buses_routes === void 0 ? void 0 : _trip_buses_routes.start_address) || \"Unknown\",\n                end_location_name: ((_trip_buses1 = trip.buses) === null || _trip_buses1 === void 0 ? void 0 : (_trip_buses_routes1 = _trip_buses1.routes) === null || _trip_buses_routes1 === void 0 ? void 0 : _trip_buses_routes1.end_address) || \"Unknown\",\n                travel_date: ((_trip_started_at = trip.started_at) === null || _trip_started_at === void 0 ? void 0 : _trip_started_at.split(\"T\")[0]) || new Date().toISOString().split(\"T\")[0],\n                route_name: ((_trip_buses2 = trip.buses) === null || _trip_buses2 === void 0 ? void 0 : (_trip_buses_routes2 = _trip_buses2.routes) === null || _trip_buses_routes2 === void 0 ? void 0 : _trip_buses_routes2.name) || \"Unknown Route\",\n                status: trip.status,\n                created_at: trip.started_at,\n                user: trip.driver\n            };\n        })) || [];\n        return {\n            data: transformedData,\n            error: null\n        };\n    }\n    return {\n        data: commuterData,\n        error: commuterError\n    };\n};\n// Update Operations\nconst updateBusStatus = async (busId, status)=>{\n    const { data, error } = await _supabase__WEBPACK_IMPORTED_MODULE_0__.supabase.from(\"buses\").update({\n        status,\n        updated_at: new Date().toISOString()\n    }).eq(\"id\", busId).select();\n    return {\n        data,\n        error\n    };\n};\nconst assignDriverToBus = async (busId, driverId)=>{\n    const { data, error } = await _supabase__WEBPACK_IMPORTED_MODULE_0__.supabase.from(\"buses\").update({\n        driver_id: driverId,\n        updated_at: new Date().toISOString()\n    }).eq(\"id\", busId).select();\n    return {\n        data,\n        error\n    };\n};\nconst updateBusAssignment = async (busId, updates)=>{\n    const { driverId, conductorId } = updates;\n    // Build update payload - explicitly set to null if clearing, or the value if setting\n    const updatePayload = {\n        updated_at: new Date().toISOString(),\n        // Always include both fields - set to null if empty string or undefined\n        driver_id: driverId || null,\n        conductor_id: conductorId || null\n    };\n    console.log(\"updateBusAssignment called with:\", {\n        busId,\n        updates\n    });\n    console.log(\"Update payload:\", updatePayload);\n    const { data, error } = await _supabase__WEBPACK_IMPORTED_MODULE_0__.supabase.from(\"buses\").update(updatePayload).eq(\"id\", busId).select();\n    console.log(\"Update result:\", {\n        data,\n        error\n    });\n    // Check if update was successful but no rows were affected\n    if (!error && (!data || data.length === 0)) {\n        console.warn(\"No rows were updated. This may be due to RLS policies or the bus not existing.\");\n        return {\n            data: null,\n            error: {\n                message: \"Update failed: No rows were affected. Please check database permissions (RLS).\",\n                code: \"NO_ROWS_AFFECTED\"\n            }\n        };\n    }\n    return {\n        data,\n        error\n    };\n};\nconst updateTripStatus = async (tripId, status, currentLocation)=>{\n    const updateData = {\n        status,\n        updated_at: new Date().toISOString()\n    };\n    if (currentLocation) {\n        updateData.current_location = currentLocation;\n    }\n    if (status === \"completed\") {\n        updateData.ended_at = new Date().toISOString();\n    } else if (status === \"cancelled\") {\n        updateData.cancelled_at = new Date().toISOString();\n    }\n    const { data, error } = await _supabase__WEBPACK_IMPORTED_MODULE_0__.supabase.from(\"trips\").update(updateData).eq(\"id\", tripId).select();\n    return {\n        data,\n        error\n    };\n};\n\n\n;\n    // Wrapped in an IIFE to avoid polluting the global scope\n    ;\n    (function () {\n        var _a, _b;\n        // Legacy CSS implementations will `eval` browser code in a Node.js context\n        // to extract CSS. For backwards compatibility, we need to check we're in a\n        // browser context before continuing.\n        if (typeof self !== 'undefined' &&\n            // AMP / No-JS mode does not inject these helpers:\n            '$RefreshHelpers$' in self) {\n            // @ts-ignore __webpack_module__ is global\n            var currentExports = module.exports;\n            // @ts-ignore __webpack_module__ is global\n            var prevSignature = (_b = (_a = module.hot.data) === null || _a === void 0 ? void 0 : _a.prevSignature) !== null && _b !== void 0 ? _b : null;\n            // This cannot happen in MainTemplate because the exports mismatch between\n            // templating and execution.\n            self.$RefreshHelpers$.registerExportsForReactRefresh(currentExports, module.id);\n            // A module can be accepted automatically based on its exports, e.g. when\n            // it is a Refresh Boundary.\n            if (self.$RefreshHelpers$.isReactRefreshBoundary(currentExports)) {\n                // Save the previous exports signature on update so we can compare the boundary\n                // signatures. We avoid saving exports themselves since it causes memory leaks (https://github.com/vercel/next.js/pull/53797)\n                module.hot.dispose(function (data) {\n                    data.prevSignature =\n                        self.$RefreshHelpers$.getRefreshBoundarySignature(currentExports);\n                });\n                // Unconditionally accept an update to this module, we'll check if it's\n                // still a Refresh Boundary later.\n                // @ts-ignore importMeta is replaced in the loader\n                module.hot.accept();\n                // This field is set when the previous version of this module was a\n                // Refresh Boundary, letting us know we need to check for invalidation or\n                // enqueue an update.\n                if (prevSignature !== null) {\n                    // A boundary can become ineligible if its exports are incompatible\n                    // with the previous exports.\n                    //\n                    // For example, if you add/remove/change exports, we'll want to\n                    // re-execute the importing modules, and force those components to\n                    // re-render. Similarly, if you convert a class component to a\n                    // function, we want to invalidate the boundary.\n                    if (self.$RefreshHelpers$.shouldInvalidateReactRefreshBoundary(prevSignature, self.$RefreshHelpers$.getRefreshBoundarySignature(currentExports))) {\n                        module.hot.invalidate();\n                    }\n                    else {\n                        self.$RefreshHelpers$.scheduleUpdate();\n                    }\n                }\n            }\n            else {\n                // Since we just executed the code for the module, it's possible that the\n                // new exports made it ineligible for being a boundary.\n                // We only care about the case when we were _previously_ a boundary,\n                // because we already accepted this update (accidental side effect).\n                var isNoLongerABoundary = prevSignature !== null;\n                if (isNoLongerABoundary) {\n                    module.hot.invalidate();\n                }\n            }\n        }\n    })();\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,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TWlGLE9BQ1RuRixNQUFNO0lBRVR1QixRQUFRQyxHQUFHLENBQUMsa0JBQWtCO1FBQUVqQjtRQUFNSztJQUFNO0lBRTVDLDJEQUEyRDtJQUMzRCxJQUFJLENBQUNBLFNBQVUsRUFBQ0wsUUFBUUEsS0FBS0csTUFBTSxLQUFLLElBQUk7UUFDMUNhLFFBQVF1RSxJQUFJLENBQUM7UUFDYixPQUFPO1lBQ0x2RixNQUFNO1lBQ05LLE9BQU87Z0JBQ0xhLFNBQVM7Z0JBQ1Q2QixNQUFNO1lBQ1I7UUFDRjtJQUNGO0lBRUEsT0FBTztRQUFFL0M7UUFBTUs7SUFBTTtBQUN2QixFQUFFO0FBRUssTUFBTW1GLG1CQUFtQixPQUM5QkMsUUFDQWhDLFFBQ0FpQztJQUVBLE1BQU1DLGFBQWtCO1FBQ3RCbEM7UUFDQXFCLFlBQVksSUFBSWpGLE9BQU9DLFdBQVc7SUFDcEM7SUFFQSxJQUFJNEYsaUJBQWlCO1FBQ25CQyxXQUFXQyxnQkFBZ0IsR0FBR0Y7SUFDaEM7SUFFQSxJQUFJakMsV0FBVyxhQUFhO1FBQzFCa0MsV0FBV0UsUUFBUSxHQUFHLElBQUloRyxPQUFPQyxXQUFXO0lBQzlDLE9BQU8sSUFBSTJELFdBQVcsYUFBYTtRQUNqQ2tDLFdBQVdHLFlBQVksR0FBRyxJQUFJakcsT0FBT0MsV0FBVztJQUNsRDtJQUVBLE1BQU0sRUFBRUUsSUFBSSxFQUFFSyxLQUFLLEVBQUUsR0FBRyxNQUFNekIsK0NBQVFBLENBQ25DWSxJQUFJLENBQUMsU0FDTHFGLE1BQU0sQ0FBQ2MsWUFDUGhHLEVBQUUsQ0FBQyxNQUFNOEYsUUFDVGhHLE1BQU07SUFFVCxPQUFPO1FBQUVPO1FBQU1LO0lBQU07QUFDdkIsRUFBRSIsInNvdXJjZXMiOlsid2VicGFjazovL19OX0UvLi9saWIvcXVlcmllcy50cz84YTgxIl0sInNvdXJjZXNDb250ZW50IjpbImltcG9ydCB7IERhc2hib2FyZE1ldHJpY3MsIHN1cGFiYXNlIH0gZnJvbSBcIi4vc3VwYWJhc2VcIjtcclxuXHJcbi8vIFJlLWV4cG9ydCB0eXBlcyBmb3IgdXNlIGluIGNvbXBvbmVudHNcclxuZXhwb3J0IHR5cGUgeyBEYXNoYm9hcmRNZXRyaWNzIH07XHJcblxyXG4vLyBEYXNoYm9hcmQgTWV0cmljcyBRdWVyaWVzXHJcbmV4cG9ydCBjb25zdCBnZXREYXNoYm9hcmRNZXRyaWNzID0gYXN5bmMgKCk6IFByb21pc2U8RGFzaGJvYXJkTWV0cmljcz4gPT4ge1xyXG4gIGNvbnN0IFtcclxuICAgIHsgY291bnQ6IGFjdGl2ZUJ1c2VzIH0sXHJcbiAgICB7IGNvdW50OiBvbmdvaW5nVHJpcHMgfSxcclxuICAgIHsgY291bnQ6IHRvdGFsUm91dGVzIH0sXHJcbiAgICB7IGNvdW50OiB0b3RhbFVzZXJzIH0sXHJcbiAgICB7IGNvdW50OiB0b2RheVRyaXBzIH0sXHJcbiAgICB7IGNvdW50OiBjb21wbGV0ZWRUcmlwcyB9LFxyXG4gICAgeyBjb3VudDogY2FuY2VsbGVkVHJpcHMgfSxcclxuICBdID0gYXdhaXQgUHJvbWlzZS5hbGwoW1xyXG4gICAgc3VwYWJhc2VcclxuICAgICAgLmZyb20oXCJidXNlc1wiKVxyXG4gICAgICAuc2VsZWN0KFwiKlwiLCB7IGNvdW50OiBcImV4YWN0XCIsIGhlYWQ6IHRydWUgfSlcclxuICAgICAgLmVxKFwic3RhdHVzXCIsIFwiYWN0aXZlXCIpLFxyXG4gICAgc3VwYWJhc2VcclxuICAgICAgLmZyb20oXCJ0cmlwc1wiKVxyXG4gICAgICAuc2VsZWN0KFwiKlwiLCB7IGNvdW50OiBcImV4YWN0XCIsIGhlYWQ6IHRydWUgfSlcclxuICAgICAgLmVxKFwic3RhdHVzXCIsIFwib25nb2luZ1wiKSxcclxuICAgIHN1cGFiYXNlLmZyb20oXCJyb3V0ZXNcIikuc2VsZWN0KFwiKlwiLCB7IGNvdW50OiBcImV4YWN0XCIsIGhlYWQ6IHRydWUgfSksXHJcbiAgICBzdXBhYmFzZS5mcm9tKFwidXNlcnNcIikuc2VsZWN0KFwiKlwiLCB7IGNvdW50OiBcImV4YWN0XCIsIGhlYWQ6IHRydWUgfSksXHJcbiAgICBzdXBhYmFzZVxyXG4gICAgICAuZnJvbShcInRyaXBzXCIpXHJcbiAgICAgIC5zZWxlY3QoXCIqXCIsIHsgY291bnQ6IFwiZXhhY3RcIiwgaGVhZDogdHJ1ZSB9KVxyXG4gICAgICAuZ3RlKFwic3RhcnRlZF9hdFwiLCBuZXcgRGF0ZSgpLnRvSVNPU3RyaW5nKCkuc3BsaXQoXCJUXCIpWzBdKSxcclxuICAgIHN1cGFiYXNlXHJcbiAgICAgIC5mcm9tKFwidHJpcHNcIilcclxuICAgICAgLnNlbGVjdChcIipcIiwgeyBjb3VudDogXCJleGFjdFwiLCBoZWFkOiB0cnVlIH0pXHJcbiAgICAgIC5lcShcInN0YXR1c1wiLCBcImNvbXBsZXRlZFwiKSxcclxuICAgIHN1cGFiYXNlXHJcbiAgICAgIC5mcm9tKFwidHJpcHNcIilcclxuICAgICAgLnNlbGVjdChcIipcIiwgeyBjb3VudDogXCJleGFjdFwiLCBoZWFkOiB0cnVlIH0pXHJcbiAgICAgIC5lcShcInN0YXR1c1wiLCBcImNhbmNlbGxlZFwiKSxcclxuICBdKTtcclxuXHJcbiAgLy8gR2V0IHRvdGFsIHBhc3NlbmdlcnMgZnJvbSB0cmlwX3Bhc3NlbmdlcnNcclxuICBjb25zdCB7IGRhdGE6IHBhc3NlbmdlcnNEYXRhIH0gPSBhd2FpdCBzdXBhYmFzZVxyXG4gICAgLmZyb20oXCJ0cmlwX3Bhc3NlbmdlcnNcIilcclxuICAgIC5zZWxlY3QoXCIqXCIsIHsgY291bnQ6IFwiZXhhY3RcIiwgaGVhZDogdHJ1ZSB9KVxyXG4gICAgLmVxKFwic3RhdHVzXCIsIFwiYm9hcmRlZFwiKTtcclxuXHJcbiAgcmV0dXJuIHtcclxuICAgIGFjdGl2ZUJ1c2VzOiBhY3RpdmVCdXNlcyB8fCAwLFxyXG4gICAgb25nb2luZ1RyaXBzOiBvbmdvaW5nVHJpcHMgfHwgMCxcclxuICAgIHRvdGFsUm91dGVzOiB0b3RhbFJvdXRlcyB8fCAwLFxyXG4gICAgdG90YWxQYXNzZW5nZXJzOiBwYXNzZW5nZXJzRGF0YT8ubGVuZ3RoIHx8IDAsXHJcbiAgICB0b2RheVRyaXBzOiB0b2RheVRyaXBzIHx8IDAsXHJcbiAgICB0b3RhbFVzZXJzOiB0b3RhbFVzZXJzIHx8IDAsXHJcbiAgICBjb21wbGV0ZWRUcmlwczogY29tcGxldGVkVHJpcHMgfHwgMCxcclxuICAgIGNhbmNlbGxlZFRyaXBzOiBjYW5jZWxsZWRUcmlwcyB8fCAwLFxyXG4gIH07XHJcbn07XHJcblxyXG4vLyBGbGVldCBNYW5hZ2VtZW50IFF1ZXJpZXNcclxuZXhwb3J0IGNvbnN0IGdldEZsZWV0U3RhdHVzID0gYXN5bmMgKCkgPT4ge1xyXG4gIGNvbnN0IHsgZGF0YSwgZXJyb3IgfSA9IGF3YWl0IHN1cGFiYXNlXHJcbiAgICAuZnJvbShcImJ1c2VzXCIpXHJcbiAgICAuc2VsZWN0KFxyXG4gICAgICBgXHJcbiAgICAgIGlkLFxyXG4gICAgICBwbGF0ZV9udW1iZXIsXHJcbiAgICAgIGNhcGFjaXR5LFxyXG4gICAgICBwYXNzZW5nZXJzLFxyXG4gICAgICBzdGF0dXMsXHJcbiAgICAgIHJvdXRlX2lkLFxyXG4gICAgICBkcml2ZXJfaWQsXHJcbiAgICAgIHJvdXRlcyAoXHJcbiAgICAgICAgaWQsXHJcbiAgICAgICAgbmFtZSxcclxuICAgICAgICBzdGFydF9hZGRyZXNzLFxyXG4gICAgICAgIGVuZF9hZGRyZXNzXHJcbiAgICAgICksXHJcbiAgICAgIGRyaXZlcjp1c2VycyFma19kcml2ZXIgKFxyXG4gICAgICAgIGlkLFxyXG4gICAgICAgIGZ1bGxOYW1lLFxyXG4gICAgICAgIGNvbnRhY3RfbnVtYmVyXHJcbiAgICAgICksXHJcbiAgICAgIHRyaXBzIWlubmVyIChcclxuICAgICAgICBpZCxcclxuICAgICAgICBzdGF0dXMsXHJcbiAgICAgICAgY3VycmVudF9sb2NhdGlvblxyXG4gICAgICApXHJcbiAgICBgXHJcbiAgICApXHJcbiAgICAuZXEoXCJ0cmlwcy5zdGF0dXNcIiwgXCJvbmdvaW5nXCIpXHJcbiAgICAub3JkZXIoXCJwbGF0ZV9udW1iZXJcIik7XHJcblxyXG4gIHJldHVybiB7IGRhdGEsIGVycm9yIH07XHJcbn07XHJcblxyXG5leHBvcnQgY29uc3QgZ2V0QWxsQnVzZXMgPSBhc3luYyAoKSA9PiB7XHJcbiAgY29uc3QgeyBkYXRhLCBlcnJvciB9ID0gYXdhaXQgc3VwYWJhc2VcclxuICAgIC5mcm9tKFwiYnVzZXNcIilcclxuICAgIC5zZWxlY3QoXHJcbiAgICAgIGBcclxuICAgICAgaWQsXHJcbiAgICAgIHBsYXRlX251bWJlcixcclxuICAgICAgY2FwYWNpdHksXHJcbiAgICAgIHBhc3NlbmdlcnMsXHJcbiAgICAgIHN0YXR1cyxcclxuICAgICAgcm91dGVfaWQsXHJcbiAgICAgIGRyaXZlcl9pZCxcclxuICAgICAgY29uZHVjdG9yX2lkLFxyXG4gICAgICByb3V0ZXMgKFxyXG4gICAgICAgIGlkLFxyXG4gICAgICAgIG5hbWUsXHJcbiAgICAgICAgc3RhcnRfYWRkcmVzcyxcclxuICAgICAgICBlbmRfYWRkcmVzc1xyXG4gICAgICApLFxyXG4gICAgICBkcml2ZXI6dXNlcnMhZmtfZHJpdmVyIChcclxuICAgICAgICBpZCxcclxuICAgICAgICBmdWxsTmFtZSxcclxuICAgICAgICBjb250YWN0X251bWJlcixcclxuICAgICAgICBsaWNlbnNlX251bWJlcixcclxuICAgICAgICBsaWNlbnNlX2V4cGlyeVxyXG4gICAgICApLFxyXG4gICAgICBjb25kdWN0b3I6dXNlcnMhYnVzZXNfY29uZHVjdG9yX2lkX2ZrZXkgKFxyXG4gICAgICAgIGlkLFxyXG4gICAgICAgIGZ1bGxOYW1lLFxyXG4gICAgICAgIGNvbnRhY3RfbnVtYmVyXHJcbiAgICAgIClcclxuICAgIGBcclxuICAgIClcclxuICAgIC5vcmRlcihcInBsYXRlX251bWJlclwiKTtcclxuXHJcbiAgcmV0dXJuIHsgZGF0YSwgZXJyb3IgfTtcclxufTtcclxuXHJcbmV4cG9ydCBjb25zdCBnZXREcml2ZXJzID0gYXN5bmMgKCkgPT4ge1xyXG4gIGNvbnN0IHsgZGF0YSwgZXJyb3IgfSA9IGF3YWl0IHN1cGFiYXNlXHJcbiAgICAuZnJvbShcInVzZXJzXCIpXHJcbiAgICAuc2VsZWN0KFwiKlwiKVxyXG4gICAgLmluKFwicm9sZVwiLCBbXCJkcml2ZXJcIiwgXCJEcml2ZXJcIl0pXHJcbiAgICAub3JkZXIoXCJmdWxsTmFtZVwiKTtcclxuXHJcbiAgcmV0dXJuIHsgZGF0YSwgZXJyb3IgfTtcclxufTtcclxuXHJcbmV4cG9ydCBjb25zdCBnZXRDb25kdWN0b3JzID0gYXN5bmMgKCkgPT4ge1xyXG4gIGNvbnN0IHsgZGF0YSwgZXJyb3IgfSA9IGF3YWl0IHN1cGFiYXNlXHJcbiAgICAuZnJvbShcInVzZXJzXCIpXHJcbiAgICAuc2VsZWN0KFwiKlwiKVxyXG4gICAgLmluKFwicm9sZVwiLCBbXCJjb25kdWN0b3JcIiwgXCJDb25kdWN0b3JcIl0pXHJcbiAgICAub3JkZXIoXCJmdWxsTmFtZVwiKTtcclxuXHJcbiAgcmV0dXJuIHsgZGF0YSwgZXJyb3IgfTtcclxufTtcclxuXHJcbi8vIFRyaXAgTWFuYWdlbWVudCBRdWVyaWVzXHJcbmV4cG9ydCBjb25zdCBnZXRBY3RpdmVUcmlwcyA9IGFzeW5jICgpID0+IHtcclxuICBjb25zdCB7IGRhdGEsIGVycm9yIH0gPSBhd2FpdCBzdXBhYmFzZVxyXG4gICAgLmZyb20oXCJ0cmlwc1wiKVxyXG4gICAgLnNlbGVjdChcclxuICAgICAgYFxyXG4gICAgICBpZCxcclxuICAgICAgc3RhdHVzLFxyXG4gICAgICBjdXJyZW50X2xvY2F0aW9uLFxyXG4gICAgICBzdGFydGVkX2F0LFxyXG4gICAgICBidXNlcyAoXHJcbiAgICAgICAgaWQsXHJcbiAgICAgICAgcGxhdGVfbnVtYmVyLFxyXG4gICAgICAgIGNhcGFjaXR5LFxyXG4gICAgICAgIHJvdXRlcyAoXHJcbiAgICAgICAgICBpZCxcclxuICAgICAgICAgIG5hbWUsXHJcbiAgICAgICAgICBzdGFydF9hZGRyZXNzLFxyXG4gICAgICAgICAgZW5kX2FkZHJlc3NcclxuICAgICAgICApXHJcbiAgICAgICksXHJcbiAgICAgIGRyaXZlcjp1c2VycyF0cmlwc19kcml2ZXJfaWRfZmtleSAoXHJcbiAgICAgICAgaWQsXHJcbiAgICAgICAgZnVsbE5hbWUsXHJcbiAgICAgICAgY29udGFjdF9udW1iZXJcclxuICAgICAgKSxcclxuICAgICAgdHJpcF9wYXNzZW5nZXJzIChcclxuICAgICAgICBpZCxcclxuICAgICAgICBzdGF0dXMsXHJcbiAgICAgICAgYm9hcmRlZF9hdCxcclxuICAgICAgICBjb21tdXRlcjp1c2VycyAoXHJcbiAgICAgICAgICBpZCxcclxuICAgICAgICAgIGZ1bGxOYW1lXHJcbiAgICAgICAgKVxyXG4gICAgICApXHJcbiAgICBgXHJcbiAgICApXHJcbiAgICAuaW4oXCJzdGF0dXNcIiwgW1wid2FpdGluZ1wiLCBcIm9uZ29pbmdcIl0pXHJcbiAgICAub3JkZXIoXCJzdGFydGVkX2F0XCIsIHsgYXNjZW5kaW5nOiBmYWxzZSB9KTtcclxuXHJcbiAgcmV0dXJuIHsgZGF0YSwgZXJyb3IgfTtcclxufTtcclxuXHJcbmV4cG9ydCBjb25zdCBnZXRUcmlwSGlzdG9yeSA9IGFzeW5jIChsaW1pdCA9IDUwKSA9PiB7XHJcbiAgY29uc3QgeyBkYXRhLCBlcnJvciB9ID0gYXdhaXQgc3VwYWJhc2VcclxuICAgIC5mcm9tKFwidHJpcHNcIilcclxuICAgIC5zZWxlY3QoXHJcbiAgICAgIGBcclxuICAgICAgaWQsXHJcbiAgICAgIHN0YXR1cyxcclxuICAgICAgc3RhcnRlZF9hdCxcclxuICAgICAgZW5kZWRfYXQsXHJcbiAgICAgIGNhbmNlbGxlZF9hdCxcclxuICAgICAgY2FuY2VsbGF0aW9uX3JlYXNvbixcclxuICAgICAgYnVzZXMgKFxyXG4gICAgICAgIGlkLFxyXG4gICAgICAgIHBsYXRlX251bWJlcixcclxuICAgICAgICByb3V0ZXMgKFxyXG4gICAgICAgICAgaWQsXHJcbiAgICAgICAgICBuYW1lXHJcbiAgICAgICAgKVxyXG4gICAgICApLFxyXG4gICAgICBkcml2ZXI6dXNlcnMhdHJpcHNfZHJpdmVyX2lkX2ZrZXkgKFxyXG4gICAgICAgIGlkLFxyXG4gICAgICAgIGZ1bGxOYW1lXHJcbiAgICAgICksXHJcbiAgICAgIHRyaXBfcGFzc2VuZ2VycyAoXHJcbiAgICAgICAgaWQsXHJcbiAgICAgICAgc3RhdHVzXHJcbiAgICAgIClcclxuICAgIGBcclxuICAgIClcclxuICAgIC5pbihcInN0YXR1c1wiLCBbXCJjb21wbGV0ZWRcIiwgXCJjYW5jZWxsZWRcIl0pXHJcbiAgICAub3JkZXIoXCJzdGFydGVkX2F0XCIsIHsgYXNjZW5kaW5nOiBmYWxzZSB9KVxyXG4gICAgLmxpbWl0KGxpbWl0KTtcclxuXHJcbiAgcmV0dXJuIHsgZGF0YSwgZXJyb3IgfTtcclxufTtcclxuXHJcbi8vIFVzZXIgTWFuYWdlbWVudFxyXG5leHBvcnQgY29uc3QgZ2V0QWxsVXNlcnMgPSBhc3luYyAoKSA9PiB7XHJcbiAgdHJ5IHtcclxuICAgIC8vIFRyeSB0byBnZXQgZnJvbSB1c2VycyB0YWJsZVxyXG4gICAgY29uc3QgeyBkYXRhLCBlcnJvciB9ID0gYXdhaXQgc3VwYWJhc2VcclxuICAgICAgLmZyb20oXCJ1c2Vyc1wiKVxyXG4gICAgICAuc2VsZWN0KFwiKlwiKVxyXG4gICAgICAub3JkZXIoXCJ1cGRhdGVkX2F0XCIsIHsgYXNjZW5kaW5nOiBmYWxzZSB9KTtcclxuXHJcbiAgICBpZiAoZXJyb3IpIHtcclxuICAgICAgY29uc29sZS5sb2coXCJVc2VycyB0YWJsZSBxdWVyeSBmYWlsZWQ6XCIsIGVycm9yLm1lc3NhZ2UpO1xyXG4gICAgICAvLyBSZXR1cm4gZW1wdHkgYXJyYXkgaW5zdGVhZCBvZiBlcnJvciB0byBwcmV2ZW50IFVJIGNyYXNoZXNcclxuICAgICAgcmV0dXJuIHsgZGF0YTogW10sIGVycm9yOiBudWxsIH07XHJcbiAgICB9XHJcblxyXG4gICAgcmV0dXJuIHsgZGF0YSwgZXJyb3IgfTtcclxuICB9IGNhdGNoIChlcnJvcikge1xyXG4gICAgY29uc29sZS5lcnJvcihcIkVycm9yIGluIGdldEFsbFVzZXJzOlwiLCBlcnJvcik7XHJcbiAgICByZXR1cm4geyBkYXRhOiBbXSwgZXJyb3I6IG51bGwgfTtcclxuICB9XHJcbn07XHJcblxyXG5leHBvcnQgY29uc3QgZ2V0VXNlcnNCeVJvbGUgPSBhc3luYyAocm9sZTogc3RyaW5nKSA9PiB7XHJcbiAgdHJ5IHtcclxuICAgIC8vIFRyeSB0byBnZXQgZnJvbSB1c2VycyB0YWJsZVxyXG4gICAgY29uc3QgeyBkYXRhLCBlcnJvciB9ID0gYXdhaXQgc3VwYWJhc2VcclxuICAgICAgLmZyb20oXCJ1c2Vyc1wiKVxyXG4gICAgICAuc2VsZWN0KFwiKlwiKVxyXG4gICAgICAuZXEoXCJyb2xlXCIsIHJvbGUpXHJcbiAgICAgIC5vcmRlcihcImZ1bGxOYW1lXCIpO1xyXG5cclxuICAgIGlmIChlcnJvcikge1xyXG4gICAgICBjb25zb2xlLmxvZyhcIlVzZXJzIHRhYmxlIHF1ZXJ5IGZhaWxlZCBmb3Igcm9sZTpcIiwgcm9sZSwgZXJyb3IubWVzc2FnZSk7XHJcbiAgICAgIC8vIFJldHVybiBlbXB0eSBhcnJheSBpbnN0ZWFkIG9mIGVycm9yIHRvIHByZXZlbnQgVUkgY3Jhc2hlc1xyXG4gICAgICByZXR1cm4geyBkYXRhOiBbXSwgZXJyb3I6IG51bGwgfTtcclxuICAgIH1cclxuXHJcbiAgICByZXR1cm4geyBkYXRhLCBlcnJvciB9O1xyXG4gIH0gY2F0Y2ggKGVycm9yKSB7XHJcbiAgICBjb25zb2xlLmVycm9yKFwiRXJyb3IgaW4gZ2V0VXNlcnNCeVJvbGU6XCIsIGVycm9yKTtcclxuICAgIHJldHVybiB7IGRhdGE6IFtdLCBlcnJvcjogbnVsbCB9O1xyXG4gIH1cclxufTtcclxuXHJcbi8vIFJvdXRlIE1hbmFnZW1lbnQgUXVlcmllc1xyXG5leHBvcnQgY29uc3QgZ2V0QWxsUm91dGVzID0gYXN5bmMgKCkgPT4ge1xyXG4gIGNvbnN0IHsgZGF0YSwgZXJyb3IgfSA9IGF3YWl0IHN1cGFiYXNlXHJcbiAgICAuZnJvbShcInJvdXRlc1wiKVxyXG4gICAgLnNlbGVjdChcIipcIilcclxuICAgIC5vcmRlcihcImNyZWF0ZWRfYXRcIiwgeyBhc2NlbmRpbmc6IGZhbHNlIH0pO1xyXG5cclxuICByZXR1cm4geyBkYXRhLCBlcnJvciB9O1xyXG59O1xyXG5cclxuZXhwb3J0IGNvbnN0IGNyZWF0ZVJvdXRlID0gYXN5bmMgKHJvdXRlRGF0YToge1xyXG4gIG5hbWU6IHN0cmluZztcclxuICBzdGFydF9hZGRyZXNzOiBzdHJpbmc7XHJcbiAgZW5kX2FkZHJlc3M6IHN0cmluZztcclxuICBwYXRoPzogYW55O1xyXG59KSA9PiB7XHJcbiAgdHJ5IHtcclxuICAgIC8vIEZvciBQb3N0R0lTIGdlb2dyYXBoeSBjb2x1bW5zLCB3ZSBuZWVkIHRvIHVzZSBTVF9HZW9nRnJvbUdlb0pTT05cclxuICAgIC8vIEJ1dCBzdXBhYmFzZS1qcyBkb2Vzbid0IHN1cHBvcnQgdGhpcyBkaXJlY3RseSwgc28gd2UnbGwgdXNlIFJQQ1xyXG4gICAgY29uc3QgeyBkYXRhLCBlcnJvciB9ID0gYXdhaXQgc3VwYWJhc2UucnBjKFwiaW5zZXJ0X3JvdXRlXCIsIHtcclxuICAgICAgcF9uYW1lOiByb3V0ZURhdGEubmFtZSxcclxuICAgICAgcF9zdGFydF9hZGRyZXNzOiByb3V0ZURhdGEuc3RhcnRfYWRkcmVzcyxcclxuICAgICAgcF9lbmRfYWRkcmVzczogcm91dGVEYXRhLmVuZF9hZGRyZXNzLFxyXG4gICAgICBwX3BhdGhfZ2VvanNvbjogcm91dGVEYXRhLnBhdGgsXHJcbiAgICB9KTtcclxuXHJcbiAgICBpZiAoZXJyb3IpIHtcclxuICAgICAgY29uc29sZS5lcnJvcihcImNyZWF0ZVJvdXRlIGVycm9yOlwiLCBlcnJvcik7XHJcbiAgICAgIHJldHVybiB7IGRhdGE6IG51bGwsIGVycm9yIH07XHJcbiAgICB9XHJcblxyXG4gICAgcmV0dXJuIHsgZGF0YSwgZXJyb3I6IG51bGwgfTtcclxuICB9IGNhdGNoIChlcnIpIHtcclxuICAgIGNvbnNvbGUuZXJyb3IoXCJjcmVhdGVSb3V0ZSBleGNlcHRpb246XCIsIGVycik7XHJcbiAgICByZXR1cm4geyBkYXRhOiBudWxsLCBlcnJvcjogeyBtZXNzYWdlOiBTdHJpbmcoZXJyKSB9IGFzIGFueSB9O1xyXG4gIH1cclxufTtcclxuXHJcbmV4cG9ydCBjb25zdCB1cGRhdGVSb3V0ZSA9IGFzeW5jIChcclxuICByb3V0ZUlkOiBzdHJpbmcsXHJcbiAgcm91dGVEYXRhOiB7XHJcbiAgICBuYW1lPzogc3RyaW5nO1xyXG4gICAgc3RhcnRfYWRkcmVzcz86IHN0cmluZztcclxuICAgIGVuZF9hZGRyZXNzPzogc3RyaW5nO1xyXG4gICAgcGF0aD86IGFueTtcclxuICB9XHJcbikgPT4ge1xyXG4gIHRyeSB7XHJcbiAgICAvLyBVc2UgUlBDIGZ1bmN0aW9uIGZvciBQb3N0R0lTIGdlb2dyYXBoeSBoYW5kbGluZ1xyXG4gICAgY29uc3QgeyBkYXRhLCBlcnJvciB9ID0gYXdhaXQgc3VwYWJhc2UucnBjKFwidXBkYXRlX3JvdXRlXCIsIHtcclxuICAgICAgcF9yb3V0ZV9pZDogcm91dGVJZCxcclxuICAgICAgcF9uYW1lOiByb3V0ZURhdGEubmFtZSB8fCBudWxsLFxyXG4gICAgICBwX3N0YXJ0X2FkZHJlc3M6IHJvdXRlRGF0YS5zdGFydF9hZGRyZXNzIHx8IG51bGwsXHJcbiAgICAgIHBfZW5kX2FkZHJlc3M6IHJvdXRlRGF0YS5lbmRfYWRkcmVzcyB8fCBudWxsLFxyXG4gICAgICBwX3BhdGhfZ2VvanNvbjogcm91dGVEYXRhLnBhdGggfHwgbnVsbCxcclxuICAgIH0pO1xyXG5cclxuICAgIGlmIChlcnJvcikge1xyXG4gICAgICBjb25zb2xlLmVycm9yKFwidXBkYXRlUm91dGUgZXJyb3I6XCIsIGVycm9yKTtcclxuICAgICAgcmV0dXJuIHsgZGF0YTogbnVsbCwgZXJyb3IgfTtcclxuICAgIH1cclxuXHJcbiAgICByZXR1cm4geyBkYXRhLCBlcnJvcjogbnVsbCB9O1xyXG4gIH0gY2F0Y2ggKGVycikge1xyXG4gICAgY29uc29sZS5lcnJvcihcInVwZGF0ZVJvdXRlIGV4Y2VwdGlvbjpcIiwgZXJyKTtcclxuICAgIHJldHVybiB7IGRhdGE6IG51bGwsIGVycm9yOiB7IG1lc3NhZ2U6IFN0cmluZyhlcnIpIH0gYXMgYW55IH07XHJcbiAgfVxyXG59O1xyXG5cclxuZXhwb3J0IGNvbnN0IGRlbGV0ZVJvdXRlID0gYXN5bmMgKHJvdXRlSWQ6IHN0cmluZykgPT4ge1xyXG4gIHRyeSB7XHJcbiAgICAvLyBEZWJ1ZzogTG9nIGN1cnJlbnQgYXV0aCB1c2VyIGFuZCB0aGVpciByb2xlXHJcbiAgICBjb25zdCB7IGRhdGE6IHsgc2Vzc2lvbiB9IH0gPSBhd2FpdCBzdXBhYmFzZS5hdXRoLmdldFNlc3Npb24oKTtcclxuICAgIGNvbnNvbGUubG9nKFwiZGVsZXRlUm91dGUgLSBDdXJyZW50IGF1dGggdXNlciBJRDpcIiwgc2Vzc2lvbj8udXNlcj8uaWQpO1xyXG5cclxuICAgIGlmIChzZXNzaW9uPy51c2VyPy5pZCkge1xyXG4gICAgICBjb25zdCB7IGRhdGE6IHVzZXJEYXRhIH0gPSBhd2FpdCBzdXBhYmFzZVxyXG4gICAgICAgIC5mcm9tKFwidXNlcnNcIilcclxuICAgICAgICAuc2VsZWN0KFwiaWQsIGZ1bGxOYW1lLCByb2xlXCIpXHJcbiAgICAgICAgLmVxKFwiaWRcIiwgc2Vzc2lvbi51c2VyLmlkKVxyXG4gICAgICAgIC5zaW5nbGUoKTtcclxuICAgICAgY29uc29sZS5sb2coXCJkZWxldGVSb3V0ZSAtIFVzZXIgaW4gdXNlcnMgdGFibGU6XCIsIHVzZXJEYXRhKTtcclxuICAgIH0gZWxzZSB7XHJcbiAgICAgIGNvbnNvbGUuZXJyb3IoXCJkZWxldGVSb3V0ZSAtIE5vIGF1dGhlbnRpY2F0ZWQgc2Vzc2lvbiBmb3VuZCFcIik7XHJcbiAgICB9XHJcblxyXG4gICAgLy8gQWRkIC5zZWxlY3QoKSB0byBnZXQgYmFjayB0aGUgZGVsZXRlZCByb3dzIC0gdGhpcyBoZWxwcyB2ZXJpZnkgZGVsZXRpb24gYWN0dWFsbHkgaGFwcGVuZWRcclxuICAgIGNvbnN0IHsgZGF0YSwgZXJyb3IgfSA9IGF3YWl0IHN1cGFiYXNlXHJcbiAgICAgIC5mcm9tKFwicm91dGVzXCIpXHJcbiAgICAgIC5kZWxldGUoKVxyXG4gICAgICAuZXEoXCJpZFwiLCByb3V0ZUlkKVxyXG4gICAgICAuc2VsZWN0KCk7XHJcblxyXG4gICAgaWYgKGVycm9yKSB7XHJcbiAgICAgIGNvbnNvbGUuZXJyb3IoXCJkZWxldGVSb3V0ZSBlcnJvcjpcIiwgZXJyb3IpO1xyXG4gICAgICByZXR1cm4geyBkYXRhOiBudWxsLCBlcnJvciB9O1xyXG4gICAgfVxyXG5cclxuICAgIC8vIENoZWNrIGlmIHRoZSBkZWxldGUgYWN0dWFsbHkgYWZmZWN0ZWQgYW55IHJvd3NcclxuICAgIC8vIFdoZW4gUkxTIHBvbGljaWVzIGJsb2NrIGRlbGV0aW9uLCBTdXBhYmFzZSByZXR1cm5zIGVtcHR5IGRhdGEgd2l0aG91dCBhbiBlcnJvclxyXG4gICAgaWYgKCFkYXRhIHx8IGRhdGEubGVuZ3RoID09PSAwKSB7XHJcbiAgICAgIGNvbnNvbGUuZXJyb3IoXCJkZWxldGVSb3V0ZTogTm8gcm93cyB3ZXJlIGRlbGV0ZWQuIFRoaXMgbWF5IGJlIGR1ZSB0byBSTFMgcG9saWNpZXMgb3IgdGhlIHJvdXRlIG5vdCBleGlzdGluZy5cIik7XHJcbiAgICAgIHJldHVybiB7XHJcbiAgICAgICAgZGF0YTogbnVsbCxcclxuICAgICAgICBlcnJvcjoge1xyXG4gICAgICAgICAgbWVzc2FnZTogXCJEZWxldGUgZmFpbGVkOiBObyByb3dzIHdlcmUgYWZmZWN0ZWQuIFBsZWFzZSBjaGVjayBkYXRhYmFzZSBwZXJtaXNzaW9ucyAoUkxTKSBvciBlbnN1cmUgdGhlIHJvdXRlIGV4aXN0cy5cIixcclxuICAgICAgICAgIGNvZGU6IFwiTk9fUk9XU19BRkZFQ1RFRFwiXHJcbiAgICAgICAgfSBhcyBhbnlcclxuICAgICAgfTtcclxuICAgIH1cclxuXHJcbiAgICBjb25zb2xlLmxvZyhcImRlbGV0ZVJvdXRlOiBTdWNjZXNzZnVsbHkgZGVsZXRlZCByb3V0ZTpcIiwgZGF0YSk7XHJcbiAgICByZXR1cm4geyBkYXRhLCBlcnJvcjogbnVsbCB9O1xyXG4gIH0gY2F0Y2ggKGVycikge1xyXG4gICAgY29uc29sZS5lcnJvcihcImRlbGV0ZVJvdXRlIGV4Y2VwdGlvbjpcIiwgZXJyKTtcclxuICAgIHJldHVybiB7IGRhdGE6IG51bGwsIGVycm9yOiB7IG1lc3NhZ2U6IFN0cmluZyhlcnIpIH0gYXMgYW55IH07XHJcbiAgfVxyXG59O1xyXG5cclxuLy8gQW5hbHl0aWNzIFF1ZXJpZXNcclxuZXhwb3J0IGNvbnN0IGdldFRyaXBBbmFseXRpY3MgPSBhc3luYyAoZGF5cyA9IDMwKSA9PiB7XHJcbiAgY29uc3QgZGF0ZVRocmVzaG9sZCA9IG5ldyBEYXRlKERhdGUubm93KCkgLSBkYXlzICogMjQgKiA2MCAqIDYwICogMTAwMCkudG9JU09TdHJpbmcoKTtcclxuXHJcbiAgY29uc29sZS5sb2coXCJnZXRUcmlwQW5hbHl0aWNzOiBGZXRjaGluZyB0cmlwcyBmcm9tIGxhc3RcIiwgZGF5cywgXCJkYXlzLCBzaW5jZTpcIiwgZGF0ZVRocmVzaG9sZCk7XHJcblxyXG4gIC8vIEZldGNoIGFsbCB0cmlwcyAtIHNvbWUgbWF5IGhhdmUgc3RhcnRlZF9hdCBhcyBudWxsIChjYW5jZWxsZWQgYmVmb3JlIHN0YXJ0aW5nKVxyXG4gIC8vIEFsc28gZmlsdGVyIGJ5IHVwZGF0ZWRfYXQgYXMgYSBmYWxsYmFjayBmb3IgdHJpcHMgdGhhdCB3ZXJlIGNhbmNlbGxlZCBiZWZvcmUgc3RhcnRpbmdcclxuICBjb25zdCB7IGRhdGEsIGVycm9yIH0gPSBhd2FpdCBzdXBhYmFzZVxyXG4gICAgLmZyb20oXCJ0cmlwc1wiKVxyXG4gICAgLnNlbGVjdChcclxuICAgICAgYFxyXG4gICAgICBpZCxcclxuICAgICAgc3RhdHVzLFxyXG4gICAgICBzdGFydGVkX2F0LFxyXG4gICAgICBlbmRlZF9hdCxcclxuICAgICAgY2FuY2VsbGVkX2F0LFxyXG4gICAgICB1cGRhdGVkX2F0LFxyXG4gICAgICBidXNlcyAoXHJcbiAgICAgICAgcm91dGVzIChcclxuICAgICAgICAgIG5hbWVcclxuICAgICAgICApXHJcbiAgICAgIClcclxuICAgIGBcclxuICAgIClcclxuICAgIC5vcihgc3RhcnRlZF9hdC5ndGUuJHtkYXRlVGhyZXNob2xkfSx1cGRhdGVkX2F0Lmd0ZS4ke2RhdGVUaHJlc2hvbGR9YClcclxuICAgIC5vcmRlcihcInVwZGF0ZWRfYXRcIiwgeyBhc2NlbmRpbmc6IGZhbHNlIH0pO1xyXG5cclxuICBjb25zb2xlLmxvZyhcImdldFRyaXBBbmFseXRpY3MgcmVzdWx0OlwiLCB7XHJcbiAgICBjb3VudDogZGF0YT8ubGVuZ3RoIHx8IDAsXHJcbiAgICBlcnJvcixcclxuICAgIHN0YXR1c2VzOiBkYXRhPy5yZWR1Y2UoKGFjYzogYW55LCB0cmlwOiBhbnkpID0+IHtcclxuICAgICAgYWNjW3RyaXAuc3RhdHVzXSA9IChhY2NbdHJpcC5zdGF0dXNdIHx8IDApICsgMTtcclxuICAgICAgcmV0dXJuIGFjYztcclxuICAgIH0sIHt9KVxyXG4gIH0pO1xyXG5cclxuICByZXR1cm4geyBkYXRhLCBlcnJvciB9O1xyXG59O1xyXG5cclxuZXhwb3J0IGNvbnN0IGdldFJvdXRlVXRpbGl6YXRpb24gPSBhc3luYyAoKSA9PiB7XHJcbiAgY29uc3QgeyBkYXRhLCBlcnJvciB9ID0gYXdhaXQgc3VwYWJhc2UuZnJvbShcInJvdXRlc1wiKS5zZWxlY3QoYFxyXG4gICAgICBpZCxcclxuICAgICAgbmFtZSxcclxuICAgICAgc3RhcnRfYWRkcmVzcyxcclxuICAgICAgZW5kX2FkZHJlc3MsXHJcbiAgICAgIGJ1c2VzIChcclxuICAgICAgICBpZCxcclxuICAgICAgICBwbGF0ZV9udW1iZXIsXHJcbiAgICAgICAgc3RhdHVzLFxyXG4gICAgICAgIHRyaXBzIChcclxuICAgICAgICAgIGlkLFxyXG4gICAgICAgICAgc3RhdHVzLFxyXG4gICAgICAgICAgc3RhcnRlZF9hdFxyXG4gICAgICAgIClcclxuICAgICAgKVxyXG4gICAgYCk7XHJcblxyXG4gIHJldHVybiB7IGRhdGEsIGVycm9yIH07XHJcbn07XHJcblxyXG5leHBvcnQgY29uc3QgZ2V0VHJhdmVsSGlzdG9yeSA9IGFzeW5jIChsaW1pdCA9IDEwMCkgPT4ge1xyXG4gIC8vIFRyeSB0byBnZXQgZnJvbSB0cmF2ZWxfaGlzdG9yeV9jb21tdXRlciB0YWJsZSB3aXRoIHByb3BlciBqb2luXHJcbiAgY29uc3QgeyBkYXRhOiBjb21tdXRlckRhdGEsIGVycm9yOiBjb21tdXRlckVycm9yIH0gPSBhd2FpdCBzdXBhYmFzZVxyXG4gICAgLmZyb20oXCJ0cmF2ZWxfaGlzdG9yeV9jb21tdXRlclwiKVxyXG4gICAgLnNlbGVjdChcclxuICAgICAgYFxyXG4gICAgICBpZCxcclxuICAgICAgc3RhcnRfbG9jYXRpb25fbmFtZSxcclxuICAgICAgZW5kX2xvY2F0aW9uX25hbWUsXHJcbiAgICAgIHRyYXZlbF9kYXRlLFxyXG4gICAgICByb3V0ZV9uYW1lLFxyXG4gICAgICBzdGF0dXMsXHJcbiAgICAgIHVzZXI6dXNlcnMgKFxyXG4gICAgICAgIGlkLFxyXG4gICAgICAgIGZ1bGxOYW1lXHJcbiAgICAgIClcclxuICAgIGBcclxuICAgIClcclxuICAgIC5vcmRlcihcInRyYXZlbF9kYXRlXCIsIHsgYXNjZW5kaW5nOiBmYWxzZSB9KVxyXG4gICAgLmxpbWl0KGxpbWl0KTtcclxuXHJcbiAgLy8gSWYgc3VjY2Vzc2Z1bCwgcmV0dXJuIHRoZSBkYXRhXHJcbiAgaWYgKGNvbW11dGVyRGF0YSAmJiAhY29tbXV0ZXJFcnJvcikge1xyXG4gICAgcmV0dXJuIHsgZGF0YTogY29tbXV0ZXJEYXRhLCBlcnJvcjogbnVsbCB9O1xyXG4gIH1cclxuXHJcbiAgLy8gSWYgdHJhdmVsX2hpc3RvcnlfY29tbXV0ZXIgdGFibGUgZG9lc24ndCBleGlzdCwgZmFsbCBiYWNrIHRvIHRyaXBzIHRhYmxlXHJcbiAgaWYgKGNvbW11dGVyRXJyb3IgJiYgY29tbXV0ZXJFcnJvci5jb2RlID09PSBcIlBHUlNUMjAwXCIpIHtcclxuICAgIGNvbnN0IHsgZGF0YTogdHJpcHNEYXRhLCBlcnJvcjogdHJpcHNFcnJvciB9ID0gYXdhaXQgc3VwYWJhc2VcclxuICAgICAgLmZyb20oXCJ0cmlwc1wiKVxyXG4gICAgICAuc2VsZWN0KFxyXG4gICAgICAgIGBcclxuICAgICAgICBpZCxcclxuICAgICAgICBzdGF0dXMsXHJcbiAgICAgICAgc3RhcnRlZF9hdCxcclxuICAgICAgICBlbmRlZF9hdCxcclxuICAgICAgICBidXNlcyAoXHJcbiAgICAgICAgICByb3V0ZXMgKFxyXG4gICAgICAgICAgICBuYW1lLFxyXG4gICAgICAgICAgICBzdGFydF9hZGRyZXNzLFxyXG4gICAgICAgICAgICBlbmRfYWRkcmVzc1xyXG4gICAgICAgICAgKVxyXG4gICAgICAgICksXHJcbiAgICAgICAgZHJpdmVyOnVzZXJzIXRyaXBzX2RyaXZlcl9pZF9ma2V5IChcclxuICAgICAgICAgIGlkLFxyXG4gICAgICAgICAgZnVsbE5hbWVcclxuICAgICAgICApXHJcbiAgICAgIGBcclxuICAgICAgKVxyXG4gICAgICAuaW4oXCJzdGF0dXNcIiwgW1wiY29tcGxldGVkXCIsIFwiY2FuY2VsbGVkXCJdKVxyXG4gICAgICAub3JkZXIoXCJzdGFydGVkX2F0XCIsIHsgYXNjZW5kaW5nOiBmYWxzZSB9KVxyXG4gICAgICAubGltaXQobGltaXQpO1xyXG5cclxuICAgIGlmICh0cmlwc0Vycm9yKSB7XHJcbiAgICAgIHJldHVybiB7IGRhdGE6IG51bGwsIGVycm9yOiB0cmlwc0Vycm9yIH07XHJcbiAgICB9XHJcblxyXG4gICAgLy8gVHJhbnNmb3JtIHRyaXBzIGRhdGEgdG8gbWF0Y2ggZXhwZWN0ZWQgZm9ybWF0XHJcbiAgICBjb25zdCB0cmFuc2Zvcm1lZERhdGEgPVxyXG4gICAgICB0cmlwc0RhdGE/Lm1hcCgodHJpcCkgPT4gKHtcclxuICAgICAgICBpZDogdHJpcC5pZCxcclxuICAgICAgICBzdGFydF9sb2NhdGlvbl9uYW1lOlxyXG4gICAgICAgICAgKHRyaXAuYnVzZXMgYXMgYW55KT8ucm91dGVzPy5zdGFydF9hZGRyZXNzIHx8IFwiVW5rbm93blwiLFxyXG4gICAgICAgIGVuZF9sb2NhdGlvbl9uYW1lOlxyXG4gICAgICAgICAgKHRyaXAuYnVzZXMgYXMgYW55KT8ucm91dGVzPy5lbmRfYWRkcmVzcyB8fCBcIlVua25vd25cIixcclxuICAgICAgICB0cmF2ZWxfZGF0ZTpcclxuICAgICAgICAgIHRyaXAuc3RhcnRlZF9hdD8uc3BsaXQoXCJUXCIpWzBdIHx8XHJcbiAgICAgICAgICBuZXcgRGF0ZSgpLnRvSVNPU3RyaW5nKCkuc3BsaXQoXCJUXCIpWzBdLFxyXG4gICAgICAgIHJvdXRlX25hbWU6ICh0cmlwLmJ1c2VzIGFzIGFueSk/LnJvdXRlcz8ubmFtZSB8fCBcIlVua25vd24gUm91dGVcIixcclxuICAgICAgICBzdGF0dXM6IHRyaXAuc3RhdHVzLFxyXG4gICAgICAgIGNyZWF0ZWRfYXQ6IHRyaXAuc3RhcnRlZF9hdCxcclxuICAgICAgICB1c2VyOiB0cmlwLmRyaXZlcixcclxuICAgICAgfSkpIHx8IFtdO1xyXG5cclxuICAgIHJldHVybiB7IGRhdGE6IHRyYW5zZm9ybWVkRGF0YSwgZXJyb3I6IG51bGwgfTtcclxuICB9XHJcblxyXG4gIHJldHVybiB7IGRhdGE6IGNvbW11dGVyRGF0YSwgZXJyb3I6IGNvbW11dGVyRXJyb3IgfTtcclxufTtcclxuXHJcbi8vIFVwZGF0ZSBPcGVyYXRpb25zXHJcbmV4cG9ydCBjb25zdCB1cGRhdGVCdXNTdGF0dXMgPSBhc3luYyAoXHJcbiAgYnVzSWQ6IHN0cmluZyxcclxuICBzdGF0dXM6IFwiYWN0aXZlXCIgfCBcImluYWN0aXZlXCJcclxuKSA9PiB7XHJcbiAgY29uc3QgeyBkYXRhLCBlcnJvciB9ID0gYXdhaXQgc3VwYWJhc2VcclxuICAgIC5mcm9tKFwiYnVzZXNcIilcclxuICAgIC51cGRhdGUoeyBzdGF0dXMsIHVwZGF0ZWRfYXQ6IG5ldyBEYXRlKCkudG9JU09TdHJpbmcoKSB9KVxyXG4gICAgLmVxKFwiaWRcIiwgYnVzSWQpXHJcbiAgICAuc2VsZWN0KCk7XHJcblxyXG4gIHJldHVybiB7IGRhdGEsIGVycm9yIH07XHJcbn07XHJcblxyXG5leHBvcnQgY29uc3QgYXNzaWduRHJpdmVyVG9CdXMgPSBhc3luYyAoYnVzSWQ6IHN0cmluZywgZHJpdmVySWQ6IHN0cmluZykgPT4ge1xyXG4gIGNvbnN0IHsgZGF0YSwgZXJyb3IgfSA9IGF3YWl0IHN1cGFiYXNlXHJcbiAgICAuZnJvbShcImJ1c2VzXCIpXHJcbiAgICAudXBkYXRlKHsgZHJpdmVyX2lkOiBkcml2ZXJJZCwgdXBkYXRlZF9hdDogbmV3IERhdGUoKS50b0lTT1N0cmluZygpIH0pXHJcbiAgICAuZXEoXCJpZFwiLCBidXNJZClcclxuICAgIC5zZWxlY3QoKTtcclxuXHJcbiAgcmV0dXJuIHsgZGF0YSwgZXJyb3IgfTtcclxufTtcclxuXHJcbmV4cG9ydCBjb25zdCB1cGRhdGVCdXNBc3NpZ25tZW50ID0gYXN5bmMgKFxyXG4gIGJ1c0lkOiBzdHJpbmcsXHJcbiAgdXBkYXRlczogeyBkcml2ZXJJZD86IHN0cmluZyB8IG51bGw7IGNvbmR1Y3RvcklkPzogc3RyaW5nIHwgbnVsbCB9XHJcbikgPT4ge1xyXG4gIGNvbnN0IHsgZHJpdmVySWQsIGNvbmR1Y3RvcklkIH0gPSB1cGRhdGVzO1xyXG5cclxuICAvLyBCdWlsZCB1cGRhdGUgcGF5bG9hZCAtIGV4cGxpY2l0bHkgc2V0IHRvIG51bGwgaWYgY2xlYXJpbmcsIG9yIHRoZSB2YWx1ZSBpZiBzZXR0aW5nXHJcbiAgY29uc3QgdXBkYXRlUGF5bG9hZDogYW55ID0ge1xyXG4gICAgdXBkYXRlZF9hdDogbmV3IERhdGUoKS50b0lTT1N0cmluZygpLFxyXG4gICAgLy8gQWx3YXlzIGluY2x1ZGUgYm90aCBmaWVsZHMgLSBzZXQgdG8gbnVsbCBpZiBlbXB0eSBzdHJpbmcgb3IgdW5kZWZpbmVkXHJcbiAgICBkcml2ZXJfaWQ6IGRyaXZlcklkIHx8IG51bGwsXHJcbiAgICBjb25kdWN0b3JfaWQ6IGNvbmR1Y3RvcklkIHx8IG51bGwsXHJcbiAgfTtcclxuXHJcbiAgY29uc29sZS5sb2coXCJ1cGRhdGVCdXNBc3NpZ25tZW50IGNhbGxlZCB3aXRoOlwiLCB7IGJ1c0lkLCB1cGRhdGVzIH0pO1xyXG4gIGNvbnNvbGUubG9nKFwiVXBkYXRlIHBheWxvYWQ6XCIsIHVwZGF0ZVBheWxvYWQpO1xyXG5cclxuICBjb25zdCB7IGRhdGEsIGVycm9yIH0gPSBhd2FpdCBzdXBhYmFzZVxyXG4gICAgLmZyb20oXCJidXNlc1wiKVxyXG4gICAgLnVwZGF0ZSh1cGRhdGVQYXlsb2FkKVxyXG4gICAgLmVxKFwiaWRcIiwgYnVzSWQpXHJcbiAgICAuc2VsZWN0KCk7XHJcblxyXG4gIGNvbnNvbGUubG9nKFwiVXBkYXRlIHJlc3VsdDpcIiwgeyBkYXRhLCBlcnJvciB9KTtcclxuXHJcbiAgLy8gQ2hlY2sgaWYgdXBkYXRlIHdhcyBzdWNjZXNzZnVsIGJ1dCBubyByb3dzIHdlcmUgYWZmZWN0ZWRcclxuICBpZiAoIWVycm9yICYmICghZGF0YSB8fCBkYXRhLmxlbmd0aCA9PT0gMCkpIHtcclxuICAgIGNvbnNvbGUud2FybihcIk5vIHJvd3Mgd2VyZSB1cGRhdGVkLiBUaGlzIG1heSBiZSBkdWUgdG8gUkxTIHBvbGljaWVzIG9yIHRoZSBidXMgbm90IGV4aXN0aW5nLlwiKTtcclxuICAgIHJldHVybiB7XHJcbiAgICAgIGRhdGE6IG51bGwsXHJcbiAgICAgIGVycm9yOiB7XHJcbiAgICAgICAgbWVzc2FnZTogXCJVcGRhdGUgZmFpbGVkOiBObyByb3dzIHdlcmUgYWZmZWN0ZWQuIFBsZWFzZSBjaGVjayBkYXRhYmFzZSBwZXJtaXNzaW9ucyAoUkxTKS5cIixcclxuICAgICAgICBjb2RlOiBcIk5PX1JPV1NfQUZGRUNURURcIlxyXG4gICAgICB9XHJcbiAgICB9O1xyXG4gIH1cclxuXHJcbiAgcmV0dXJuIHsgZGF0YSwgZXJyb3IgfTtcclxufTtcclxuXHJcbmV4cG9ydCBjb25zdCB1cGRhdGVUcmlwU3RhdHVzID0gYXN5bmMgKFxyXG4gIHRyaXBJZDogc3RyaW5nLFxyXG4gIHN0YXR1czogc3RyaW5nLFxyXG4gIGN1cnJlbnRMb2NhdGlvbj86IGFueVxyXG4pID0+IHtcclxuICBjb25zdCB1cGRhdGVEYXRhOiBhbnkgPSB7XHJcbiAgICBzdGF0dXMsXHJcbiAgICB1cGRhdGVkX2F0OiBuZXcgRGF0ZSgpLnRvSVNPU3RyaW5nKCksXHJcbiAgfTtcclxuXHJcbiAgaWYgKGN1cnJlbnRMb2NhdGlvbikge1xyXG4gICAgdXBkYXRlRGF0YS5jdXJyZW50X2xvY2F0aW9uID0gY3VycmVudExvY2F0aW9uO1xyXG4gIH1cclxuXHJcbiAgaWYgKHN0YXR1cyA9PT0gXCJjb21wbGV0ZWRcIikge1xyXG4gICAgdXBkYXRlRGF0YS5lbmRlZF9hdCA9IG5ldyBEYXRlKCkudG9JU09TdHJpbmcoKTtcclxuICB9IGVsc2UgaWYgKHN0YXR1cyA9PT0gXCJjYW5jZWxsZWRcIikge1xyXG4gICAgdXBkYXRlRGF0YS5jYW5jZWxsZWRfYXQgPSBuZXcgRGF0ZSgpLnRvSVNPU3RyaW5nKCk7XHJcbiAgfVxyXG5cclxuICBjb25zdCB7IGRhdGEsIGVycm9yIH0gPSBhd2FpdCBzdXBhYmFzZVxyXG4gICAgLmZyb20oXCJ0cmlwc1wiKVxyXG4gICAgLnVwZGF0ZSh1cGRhdGVEYXRhKVxyXG4gICAgLmVxKFwiaWRcIiwgdHJpcElkKVxyXG4gICAgLnNlbGVjdCgpO1xyXG5cclxuICByZXR1cm4geyBkYXRhLCBlcnJvciB9O1xyXG59O1xyXG4iXSwibmFtZXMiOlsic3VwYWJhc2UiLCJnZXREYXNoYm9hcmRNZXRyaWNzIiwiY291bnQiLCJhY3RpdmVCdXNlcyIsIm9uZ29pbmdUcmlwcyIsInRvdGFsUm91dGVzIiwidG90YWxVc2VycyIsInRvZGF5VHJpcHMiLCJjb21wbGV0ZWRUcmlwcyIsImNhbmNlbGxlZFRyaXBzIiwiUHJvbWlzZSIsImFsbCIsImZyb20iLCJzZWxlY3QiLCJoZWFkIiwiZXEiLCJndGUiLCJEYXRlIiwidG9JU09TdHJpbmciLCJzcGxpdCIsImRhdGEiLCJwYXNzZW5nZXJzRGF0YSIsInRvdGFsUGFzc2VuZ2VycyIsImxlbmd0aCIsImdldEZsZWV0U3RhdHVzIiwiZXJyb3IiLCJvcmRlciIsImdldEFsbEJ1c2VzIiwiZ2V0RHJpdmVycyIsImluIiwiZ2V0Q29uZHVjdG9ycyIsImdldEFjdGl2ZVRyaXBzIiwiYXNjZW5kaW5nIiwiZ2V0VHJpcEhpc3RvcnkiLCJsaW1pdCIsImdldEFsbFVzZXJzIiwiY29uc29sZSIsImxvZyIsIm1lc3NhZ2UiLCJnZXRVc2Vyc0J5Um9sZSIsInJvbGUiLCJnZXRBbGxSb3V0ZXMiLCJjcmVhdGVSb3V0ZSIsInJvdXRlRGF0YSIsInJwYyIsInBfbmFtZSIsIm5hbWUiLCJwX3N0YXJ0X2FkZHJlc3MiLCJzdGFydF9hZGRyZXNzIiwicF9lbmRfYWRkcmVzcyIsImVuZF9hZGRyZXNzIiwicF9wYXRoX2dlb2pzb24iLCJwYXRoIiwiZXJyIiwiU3RyaW5nIiwidXBkYXRlUm91dGUiLCJyb3V0ZUlkIiwicF9yb3V0ZV9pZCIsImRlbGV0ZVJvdXRlIiwic2Vzc2lvbiIsImF1dGgiLCJnZXRTZXNzaW9uIiwidXNlciIsImlkIiwidXNlckRhdGEiLCJzaW5nbGUiLCJkZWxldGUiLCJjb2RlIiwiZ2V0VHJpcEFuYWx5dGljcyIsImRheXMiLCJkYXRlVGhyZXNob2xkIiwibm93Iiwib3IiLCJzdGF0dXNlcyIsInJlZHVjZSIsImFjYyIsInRyaXAiLCJzdGF0dXMiLCJnZXRSb3V0ZVV0aWxpemF0aW9uIiwiZ2V0VHJhdmVsSGlzdG9yeSIsImNvbW11dGVyRGF0YSIsImNvbW11dGVyRXJyb3IiLCJ0cmlwc0RhdGEiLCJ0cmlwc0Vycm9yIiwidHJhbnNmb3JtZWREYXRhIiwibWFwIiwic3RhcnRfbG9jYXRpb25fbmFtZSIsImJ1c2VzIiwicm91dGVzIiwiZW5kX2xvY2F0aW9uX25hbWUiLCJ0cmF2ZWxfZGF0ZSIsInN0YXJ0ZWRfYXQiLCJyb3V0ZV9uYW1lIiwiY3JlYXRlZF9hdCIsImRyaXZlciIsInVwZGF0ZUJ1c1N0YXR1cyIsImJ1c0lkIiwidXBkYXRlIiwidXBkYXRlZF9hdCIsImFzc2lnbkRyaXZlclRvQnVzIiwiZHJpdmVySWQiLCJkcml2ZXJfaWQiLCJ1cGRhdGVCdXNBc3NpZ25tZW50IiwidXBkYXRlcyIsImNvbmR1Y3RvcklkIiwidXBkYXRlUGF5bG9hZCIsImNvbmR1Y3Rvcl9pZCIsIndhcm4iLCJ1cGRhdGVUcmlwU3RhdHVzIiwidHJpcElkIiwiY3VycmVudExvY2F0aW9uIiwidXBkYXRlRGF0YSIsImN1cnJlbnRfbG9jYXRpb24iLCJlbmRlZF9hdCIsImNhbmNlbGxlZF9hdCJdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(app-pages-browser)/./lib/queries.ts\n"));

/***/ })

});